<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Weather Flow</title>

    <!-- PWA Meta Tags -->
    <meta name="application-name" content="Weather Flow">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Weather Flow">
    <meta name="theme-color" content="#0d1117">
    <meta name="description" content="Beautiful weather visualization with flowing ribbons">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Fonts -->

    <!-- Icons -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(160deg, #0d1117 0%, #161b22 40%, #1a2332 70%, #0f1a2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 0 20px;
            padding-top: 5vh;
            position: relative;
            /* Prevent horizontal scroll from swipe gestures */
            overflow-x: hidden;
        }

        /* Weather display wrapper - keeps sky and temperature together as one unit */
        .weather-display-wrapper {
            position: relative;
            width: 100%;
            z-index: 1;
            overflow: visible;
            /* Padding reduced since temp curve moved up 200px */
            padding-bottom: 50px;
        }

        #tempCurveCanvas, #windCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        #tempCurveCanvas { z-index: 0; }
        #windCanvas { z-index: 1; }
        #worldMapCanvas {
            display: block;
            margin: 0 auto;
            position: relative;
            z-index: 2;
            pointer-events: none;
            opacity: 0;
            transition: opacity 5s ease-in-out;
            cursor: crosshair;
        }
        #worldMapCanvas.visible {
            opacity: 1;
            transition: opacity 0.8s ease-out;
            pointer-events: auto;
        }

        #tempCurveOverlay {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
        }

        /* Tooltips - fixed on desktop for smooth tracking */
        .temp-tooltip, .sky-tooltip {
            position: fixed;
        }

        /* On touch devices, hide tooltips and disable overlay to avoid interference with taps */
        .touch-device .temp-tooltip,
        .touch-device .sky-tooltip {
            display: none !important;
        }

        .touch-device #tempCurveOverlay {
            pointer-events: none;
        }


        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 2;
            /* Position the sky ribbon at the top of the wrapper */
            padding-top: 10px;
        }

        .ribbon-row {
            display: flex;
            align-items: flex-start;
        }

        .ribbon-wrapper {
            flex: 1;
            height: 100px;
            position: relative;
            border-radius: 50px;
            overflow: hidden;
        }

        .ribbon-wrapper.dynamic-height {
            height: auto;
            min-height: 100px;
            border-radius: 50px 50px 0 0;
        }

        .ribbon-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .day-selector {
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            bottom: 9px;
            left: 0;
            right: 0;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .day-selector.visible {
            opacity: 1;
        }

        .day-selector-content {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .day-selector-content > * + * { margin-left: 16px; }

        .selector-divider {
            display: none;
        }

        .location-section {
            display: flex;
            align-items: center;
        }
        .location-section > * + * { margin-left: 8px; }

        .random-btn {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            color: rgba(180, 190, 210, 0.7);
            font-size: 0.7rem;
            padding: 4px 10px;
            cursor: pointer;
            transition: all 0.25s ease;
            letter-spacing: 0.5px;
        }

        .random-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.15);
            color: #e8eaef;
        }
        .date-nav {
            display: flex;
            align-items: center;
            position: relative;
        }
        .date-nav > * + * { margin-left: 8px; }

        .forecast-limit-msg {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 4px;
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.5);
            padding: 4px 12px;
            white-space: nowrap;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
        }

        .city-label, .day-label {
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 15px;
            transition: all 0.25s ease;
            text-align: center;
            letter-spacing: 0.5px;
        }
        .city-label:hover, .day-label:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        .city-label {
            color: rgba(235, 238, 245, 0.9);
            font-size: 0.9rem;
            min-width: 120px;
            position: relative;
        }
        .city-label:hover { color: #fff; }

        .set-default-btn {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 4px;
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            padding: 4px 12px;
            transition: all 0.25s ease;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
            white-space: nowrap;
        }
        .set-default-btn:hover {
            color: rgba(255, 255, 255, 0.9);
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .city-input {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            color: #fff;
            font-size: 0.9rem;
            letter-spacing: 1px;
            padding: 6px 12px;
            outline: none;
            width: 150px;
        }

        .city-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .city-input-wrapper {
            position: relative;
            min-width: 120px;
            text-align: center;
        }

        .city-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: rgba(30, 40, 60, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            overflow: hidden;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .city-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.2s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .city-suggestion:last-child {
            border-bottom: none;
        }

        .city-suggestion:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .city-suggestion-name {
            color: #fff;
            font-size: 0.9rem;
        }

        .city-suggestion-detail {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
            margin-left: 4px;
        }

        .day-arrow {
            width: 36px;
            height: 36px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.06);
            color: rgba(180, 190, 210, 0.8);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.25s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .day-arrow:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.15);
            color: #e8eaef;
        }

        .day-arrow:disabled {
            opacity: 0.25;
            cursor: not-allowed;
        }

        .day-label {
            color: rgba(235, 238, 245, 0.9);
            font-size: 0.9rem;
            min-width: 140px;
            text-align: center;
            white-space: nowrap;
        }
        .day-label:hover { color: #fff; }

        /* Year temperature band */
        .year-band-container {
            width: 100%;
            max-width: 1200px;
            margin: 20px auto 0;
            height: 18px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 5s ease-in-out;
            pointer-events: none;
            position: relative;
            z-index: 5;
        }
        .year-band-container.visible {
            opacity: 1;
            transition: opacity 0.8s ease-out;
            pointer-events: auto;
        }
        #yearBandCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .year-band-tooltip {
            position: fixed;
            background: rgba(8, 12, 20, 0.85);
            color: #fff;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 0.78rem;
            pointer-events: none;
            z-index: 100;
            display: none;
            transform: translate(-50%, -100%);
            margin-top: -8px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
        }

        .temp-tooltip, .sky-tooltip {
            background: rgba(8, 12, 20, 0.85);
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 100;
            display: none;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            text-align: center;
            line-height: 1.4;
        }

        .tooltip-hour {
            font-size: 0.85rem;
            color: rgba(200, 210, 230, 0.8);
            margin-bottom: 2px;
        }

        .tooltip-value {
            font-size: 0.85rem;
        }

        /* Responsive styles for mobile */
        @media (max-width: 768px) {
            body {
                padding: 0 10px;
                padding-top: 3vh;
            }

            .container {
                padding-top: 5px;
            }

            .weather-display-wrapper {
                padding-bottom: 40px;
            }

            .day-selector {
                bottom: 9px;
            }

            .day-selector-content > * + * { margin-left: 12px; }

            .date-nav > * + * { margin-left: 6px; }

            .day-label {
                font-size: 0.8rem;
                min-width: 120px;
            }

            .city-label {
                font-size: 0.8rem;
                min-width: 80px;
            }

            .random-btn {
                font-size: 0.65rem;
                padding: 3px 8px;
            }

            .ribbon-wrapper {
                height: 80px;
            }

            .ribbon-wrapper.dynamic-height {
                min-height: 80px;
            }

            .year-band-container {
                height: 16px;
            }
        }

        /* Portrait smartphone layout */
        @media (max-width: 480px) and (orientation: portrait) {
            body {
                padding: 0 5px;
                padding-top: 2vh;
            }

            .container {
                padding-top: 5px;
            }

            .weather-display-wrapper {
                padding-bottom: 20px;
            }

            .day-selector {
                position: relative;
                bottom: auto;
                margin-top: 15px;
            }

            .day-selector-content {
                width: 100%;
                flex-direction: row;
                justify-content: space-between;
                padding: 0 15px;
            }
            .day-selector-content > * + * { margin-left: 10px; }

            .date-nav > * + * { margin-left: 4px; }

            .day-label {
                font-size: 0.8rem;
                min-width: auto;
                text-align: left;
            }

            .city-label {
                font-size: 0.8rem;
                min-width: auto;
                text-align: right;
            }

            .location-section > * + * { margin-left: 6px; }

            .random-btn {
                font-size: 0.6rem;
                padding: 3px 6px;
            }

            .selector-divider {
                display: none;
            }

            .year-band-container {
                height: 14px;
                margin: 4px 5px 0;
            }
        }

        /* Landscape smartphone - keep centered layout */
        @media (max-width: 480px) and (orientation: landscape) {
            body {
                padding: 0 10px;
                padding-top: 2vh;
            }

            .day-selector {
                bottom: 0px;
            }

            .day-selector-content > * + * { margin-left: 10px; }

            .date-nav > * + * { margin-left: 4px; }

            .day-label, .city-label {
                font-size: 0.75rem;
            }

            .day-label {
                min-width: 100px;
            }

            .random-btn {
                font-size: 0.6rem;
                padding: 2px 6px;
            }
        }

        /* Hide arrows on touch devices */
        .touch-device .day-arrow {
            display: none;
        }

        .touch-device .date-nav {
            gap: 0;
        }

        /* Swipe indicator for touch devices */
        .swipe-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(180, 195, 220, 0.35);
            font-size: 0.7rem;
            letter-spacing: 0.5px;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .swipe-indicator.hidden {
            opacity: 0;
        }

        /* Loading overlay for day/city navigation */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.visible {
            opacity: 1;
        }

        .loading-skeleton {
            position: absolute;
            top: 10px;
            left: 0;
            right: 0;
            height: 144px;
            border-radius: 50px 50px 0 0;
            background: linear-gradient(90deg,
                rgba(30, 40, 60, 0.6) 0%,
                rgba(50, 65, 90, 0.8) 50%,
                rgba(30, 40, 60, 0.6) 100%);
            background-size: 200% 100%;
            animation: shimmer 1.5s ease-in-out infinite;
            overflow: hidden;
        }

        .loading-skeleton::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg,
                transparent 0%,
                rgba(255, 255, 255, 0.03) 50%,
                transparent 100%);
        }

        .loading-curve {
            position: absolute;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(90deg,
                rgba(80, 100, 140, 0.2) 0%,
                rgba(100, 130, 170, 0.4) 50%,
                rgba(80, 100, 140, 0.2) 100%);
            background-size: 200% 100%;
            animation: shimmer 1.5s ease-in-out infinite;
            animation-delay: 0.2s;
            mask-image: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%);
            -webkit-mask-image: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%);
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* Splash title shown on initial page load */
        .splash-title {
            position: absolute;
            top: -15px;
            left: 0;
            right: 0;
            height: 160px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.6s ease;
        }

        .splash-title.hidden {
            opacity: 0;
        }

        .splash-inner {
            display: inline-block;
            position: relative;
        }

        .splash-title .splash-main {
            font-family: 'Avenir Next', 'Avenir', sans-serif;
            font-weight: 500;
            font-size: 3.2rem;
            color: rgb(30, 80, 160);
            letter-spacing: 0.18em;
            line-height: 1;
            white-space: nowrap;
            text-transform: lowercase;
        }

        .splash-title .splash-sub {
            font-family: 'Avenir Next', 'Avenir', sans-serif;
            font-weight: 500;
            font-size: 0.78rem;
            letter-spacing: 0.22em;
            color: rgb(30, 80, 160);
            margin-top: -2px;
            margin-left: 1rem;
            text-align: left;
        }

        @media (max-width: 480px) {
            .splash-title .splash-main {
                font-size: 2rem;
            }
            .splash-title .splash-sub {
                font-size: 0.5rem;
            }
        }

        /* Hover title - appears when mouse is above sky ribbon */
        .hover-title {
            position: absolute;
            top: -15px;
            left: 0;
            right: 0;
            height: 160px;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.8s ease;
        }

        .hover-title.visible {
            opacity: 1;
        }

        .hover-title .hover-inner {
            display: inline-block;
            position: relative;
        }

        .hover-title .hover-main {
            font-family: 'Avenir Next', 'Avenir', sans-serif;
            font-weight: 500;
            font-size: 3.2rem;
            color: rgb(30, 80, 160);
            letter-spacing: 0.18em;
            line-height: 1;
            white-space: nowrap;
            text-transform: lowercase;
        }

        .hover-title .hover-sub {
            font-family: 'Avenir Next', 'Avenir', sans-serif;
            font-weight: 500;
            font-size: 0.78rem;
            letter-spacing: 0.22em;
            color: rgb(30, 80, 160);
            margin-top: -2px;
            margin-left: 1rem;
            text-align: left;
        }

        .touch-device .hover-title {
            display: none;
        }

        @media (max-width: 480px) {
            .hover-title .hover-main {
                font-size: 2rem;
            }
            .hover-title .hover-sub {
                font-size: 0.5rem;
            }
        }

    </style>
</head>
<body>
    <div class="weather-display-wrapper" id="weatherDisplayWrapper">
        <div class="splash-title" id="splashTitle"><div class="splash-inner"><div class="splash-main">weather flow</div><div class="splash-sub">forecast <span style="opacity:1">w</span><span style="opacity:0.95">i</span><span style="opacity:0.91">t</span><span style="opacity:0.86">h</span><span style="opacity:0.81">o</span><span style="opacity:0.77">u</span><span style="opacity:0.72">t</span><span style="opacity:0.67"> </span><span style="opacity:0.63">n</span><span style="opacity:0.58">u</span><span style="opacity:0.53">m</span><span style="opacity:0.49">b</span><span style="opacity:0.44">e</span><span style="opacity:0.39">r</span><span style="opacity:0.35">s</span></div></div></div>
        <div class="hover-title" id="hoverTitle"><div class="hover-inner"><div class="hover-main">weather flow</div><div class="hover-sub">forecast <span style="opacity:1">w</span><span style="opacity:0.95">i</span><span style="opacity:0.91">t</span><span style="opacity:0.86">h</span><span style="opacity:0.81">o</span><span style="opacity:0.77">u</span><span style="opacity:0.72">t</span><span style="opacity:0.67"> </span><span style="opacity:0.63">n</span><span style="opacity:0.58">u</span><span style="opacity:0.53">m</span><span style="opacity:0.49">b</span><span style="opacity:0.44">e</span><span style="opacity:0.39">r</span><span style="opacity:0.35">s</span></div></div></div>
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-skeleton"></div>
            <div class="loading-curve" id="loadingCurve"></div>
        </div>
        <canvas id="tempCurveCanvas"></canvas>
        <canvas id="windCanvas"></canvas>
        <div id="tempCurveOverlay"></div>
        <div class="temp-tooltip" id="tempTooltip"></div>

        <div class="container">
            <div class="ribbon-row">
                <div class="ribbon-wrapper dynamic-height">
                    <canvas id="skyRibbon" class="ribbon-canvas"></canvas>
                </div>
            </div>
        </div>
        <div class="sky-tooltip" id="skyTooltip"></div>

        <div class="day-selector">
            <div class="day-selector-content">
                <div class="date-nav">
                    <button class="day-arrow" id="prevDay">&#8592;</button>
                    <span class="day-label" id="dayLabel">Today</span>
                    <button class="day-arrow" id="nextDay">&#8594;</button>
                </div>
                <div class="location-section">
                    <span class="city-label" id="cityLabel">Tokyo</span>
                    <button class="random-btn" id="randomBtn">random</button>
                    <!-- <button class="random-btn" id="similarBtn">similar</button> -->
                </div>
            </div>
        </div>
    </div>
    <div class="year-band-container" id="yearBandContainer">
        <canvas id="yearBandCanvas"></canvas>
        <div class="year-band-tooltip" id="yearBandTooltip"></div>
    </div>
    <div class="swipe-indicator" id="swipeIndicator">tap left/right of sky to change day</div>
    <canvas id="worldMapCanvas"></canvas>

    <script>
        // City coordinates for weather API
        const cities = {
            'tokyo': { name: 'Tokyo', lat: 35.68, lon: 139.69, timezone: 'Asia/Tokyo' },
            'riyadh': { name: 'Riyadh', lat: 24.69, lon: 46.72, timezone: 'Asia/Riyadh' },
            'baltimore': { name: 'Baltimore', lat: 39.29, lon: -76.61, timezone: 'America/New_York' },
            'mexico-city': { name: 'Mexico City', lat: 19.43, lon: -99.13, timezone: 'America/Mexico_City' },
            'brasilia': { name: 'Brasília', lat: -15.79, lon: -47.88, timezone: 'America/Sao_Paulo' },
            'abu-dhabi': { name: 'Abu Dhabi', lat: 24.45, lon: 54.37, timezone: 'Asia/Dubai' }
        };

        // World capitals for random selection
        const worldCapitals = [
            { name: 'Tokyo', lat: 35.68, lon: 139.69, timezone: 'Asia/Tokyo' },
            { name: 'Beijing', lat: 39.90, lon: 116.41, timezone: 'Asia/Shanghai' },
            { name: 'Seoul', lat: 37.57, lon: 126.98, timezone: 'Asia/Seoul' },
            { name: 'New Delhi', lat: 28.61, lon: 77.21, timezone: 'Asia/Kolkata' },
            { name: 'Bangkok', lat: 13.76, lon: 100.50, timezone: 'Asia/Bangkok' },
            { name: 'Jakarta', lat: -6.21, lon: 106.85, timezone: 'Asia/Jakarta' },
            { name: 'Manila', lat: 14.60, lon: 120.98, timezone: 'Asia/Manila' },
            { name: 'Singapore', lat: 1.29, lon: 103.85, timezone: 'Asia/Singapore' },
            { name: 'Kuala Lumpur', lat: 3.14, lon: 101.69, timezone: 'Asia/Kuala_Lumpur' },
            { name: 'Hanoi', lat: 21.03, lon: 105.85, timezone: 'Asia/Ho_Chi_Minh' },
            { name: 'Taipei', lat: 25.03, lon: 121.57, timezone: 'Asia/Taipei' },
            { name: 'Moscow', lat: 55.76, lon: 37.62, timezone: 'Europe/Moscow' },
            { name: 'London', lat: 51.51, lon: -0.13, timezone: 'Europe/London' },
            { name: 'Paris', lat: 48.86, lon: 2.35, timezone: 'Europe/Paris' },
            { name: 'Berlin', lat: 52.52, lon: 13.41, timezone: 'Europe/Berlin' },
            { name: 'Rome', lat: 41.90, lon: 12.50, timezone: 'Europe/Rome' },
            { name: 'Madrid', lat: 40.42, lon: -3.70, timezone: 'Europe/Madrid' },
            { name: 'Lisbon', lat: 38.72, lon: -9.14, timezone: 'Europe/Lisbon' },
            { name: 'Amsterdam', lat: 52.37, lon: 4.90, timezone: 'Europe/Amsterdam' },
            { name: 'Brussels', lat: 50.85, lon: 4.35, timezone: 'Europe/Brussels' },
            { name: 'Vienna', lat: 48.21, lon: 16.37, timezone: 'Europe/Vienna' },
            { name: 'Prague', lat: 50.08, lon: 14.44, timezone: 'Europe/Prague' },
            { name: 'Warsaw', lat: 52.23, lon: 21.01, timezone: 'Europe/Warsaw' },
            { name: 'Budapest', lat: 47.50, lon: 19.04, timezone: 'Europe/Budapest' },
            { name: 'Athens', lat: 37.98, lon: 23.73, timezone: 'Europe/Athens' },
            { name: 'Stockholm', lat: 59.33, lon: 18.07, timezone: 'Europe/Stockholm' },
            { name: 'Oslo', lat: 59.91, lon: 10.75, timezone: 'Europe/Oslo' },
            { name: 'Copenhagen', lat: 55.68, lon: 12.57, timezone: 'Europe/Copenhagen' },
            { name: 'Helsinki', lat: 60.17, lon: 24.94, timezone: 'Europe/Helsinki' },
            { name: 'Dublin', lat: 53.35, lon: -6.26, timezone: 'Europe/Dublin' },
            { name: 'Reykjavik', lat: 64.15, lon: -21.94, timezone: 'Atlantic/Reykjavik' },
            { name: 'Bern', lat: 46.95, lon: 7.45, timezone: 'Europe/Zurich' },
            { name: 'Washington D.C.', lat: 38.91, lon: -77.04, timezone: 'America/New_York' },
            { name: 'Ottawa', lat: 45.42, lon: -75.70, timezone: 'America/Toronto' },
            { name: 'Mexico City', lat: 19.43, lon: -99.13, timezone: 'America/Mexico_City' },
            { name: 'Havana', lat: 23.11, lon: -82.37, timezone: 'America/Havana' },
            { name: 'Guatemala City', lat: 14.63, lon: -90.51, timezone: 'America/Guatemala' },
            { name: 'San José', lat: 9.93, lon: -84.08, timezone: 'America/Costa_Rica' },
            { name: 'Panama City', lat: 8.98, lon: -79.52, timezone: 'America/Panama' },
            { name: 'Bogotá', lat: 4.71, lon: -74.07, timezone: 'America/Bogota' },
            { name: 'Caracas', lat: 10.49, lon: -66.88, timezone: 'America/Caracas' },
            { name: 'Lima', lat: -12.05, lon: -77.04, timezone: 'America/Lima' },
            { name: 'Quito', lat: -0.18, lon: -78.47, timezone: 'America/Guayaquil' },
            { name: 'La Paz', lat: -16.50, lon: -68.15, timezone: 'America/La_Paz' },
            { name: 'Santiago', lat: -33.45, lon: -70.67, timezone: 'America/Santiago' },
            { name: 'Buenos Aires', lat: -34.60, lon: -58.38, timezone: 'America/Argentina/Buenos_Aires' },
            { name: 'Montevideo', lat: -34.90, lon: -56.19, timezone: 'America/Montevideo' },
            { name: 'Brasília', lat: -15.79, lon: -47.88, timezone: 'America/Sao_Paulo' },
            { name: 'Cairo', lat: 30.04, lon: 31.24, timezone: 'Africa/Cairo' },
            { name: 'Nairobi', lat: -1.29, lon: 36.82, timezone: 'Africa/Nairobi' },
            { name: 'Cape Town', lat: -33.93, lon: 18.42, timezone: 'Africa/Johannesburg' },
            { name: 'Lagos', lat: 6.52, lon: 3.38, timezone: 'Africa/Lagos' },
            { name: 'Accra', lat: 5.56, lon: -0.19, timezone: 'Africa/Accra' },
            { name: 'Casablanca', lat: 33.57, lon: -7.59, timezone: 'Africa/Casablanca' },
            { name: 'Tunis', lat: 36.81, lon: 10.18, timezone: 'Africa/Tunis' },
            { name: 'Algiers', lat: 36.74, lon: 3.06, timezone: 'Africa/Algiers' },
            { name: 'Addis Ababa', lat: 9.03, lon: 38.75, timezone: 'Africa/Addis_Ababa' },
            { name: 'Riyadh', lat: 24.69, lon: 46.72, timezone: 'Asia/Riyadh' },
            { name: 'Dubai', lat: 25.20, lon: 55.27, timezone: 'Asia/Dubai' },
            { name: 'Tel Aviv', lat: 32.09, lon: 34.78, timezone: 'Asia/Jerusalem' },
            { name: 'Ankara', lat: 39.93, lon: 32.86, timezone: 'Europe/Istanbul' },
            { name: 'Tehran', lat: 35.69, lon: 51.39, timezone: 'Asia/Tehran' },
            { name: 'Islamabad', lat: 33.69, lon: 73.06, timezone: 'Asia/Karachi' },
            { name: 'Dhaka', lat: 23.81, lon: 90.41, timezone: 'Asia/Dhaka' },
            { name: 'Kathmandu', lat: 27.72, lon: 85.32, timezone: 'Asia/Kathmandu' },
            { name: 'Colombo', lat: 6.93, lon: 79.85, timezone: 'Asia/Colombo' },
            { name: 'Canberra', lat: -35.28, lon: 149.13, timezone: 'Australia/Sydney' },
            { name: 'Wellington', lat: -41.29, lon: 174.78, timezone: 'Pacific/Auckland' },
            { name: 'Suva', lat: -18.14, lon: 178.44, timezone: 'Pacific/Fiji' },
            { name: 'Ulaanbaatar', lat: 47.92, lon: 106.92, timezone: 'Asia/Ulaanbaatar' },
            { name: 'Pyongyang', lat: 39.04, lon: 125.76, timezone: 'Asia/Pyongyang' },
            { name: 'Phnom Penh', lat: 11.56, lon: 104.92, timezone: 'Asia/Phnom_Penh' },
            { name: 'Vientiane', lat: 17.97, lon: 102.63, timezone: 'Asia/Vientiane' },
            { name: 'Yangon', lat: 16.87, lon: 96.20, timezone: 'Asia/Yangon' },
            { name: 'Thimphu', lat: 27.47, lon: 89.64, timezone: 'Asia/Thimphu' },
            { name: 'Kabul', lat: 34.53, lon: 69.17, timezone: 'Asia/Kabul' },
            { name: 'Tashkent', lat: 41.30, lon: 69.28, timezone: 'Asia/Tashkent' },
            { name: 'Astana', lat: 51.17, lon: 71.43, timezone: 'Asia/Almaty' },
            { name: 'Tbilisi', lat: 41.72, lon: 44.79, timezone: 'Asia/Tbilisi' },
            { name: 'Yerevan', lat: 40.18, lon: 44.51, timezone: 'Asia/Yerevan' },
            { name: 'Baku', lat: 40.41, lon: 49.87, timezone: 'Asia/Baku' },
            { name: 'Kyiv', lat: 50.45, lon: 30.52, timezone: 'Europe/Kiev' },
            { name: 'Minsk', lat: 53.90, lon: 27.57, timezone: 'Europe/Minsk' },
            { name: 'Vilnius', lat: 54.69, lon: 25.28, timezone: 'Europe/Vilnius' },
            { name: 'Riga', lat: 56.95, lon: 24.11, timezone: 'Europe/Riga' },
            { name: 'Tallinn', lat: 59.44, lon: 24.75, timezone: 'Europe/Tallinn' },
            { name: 'Bucharest', lat: 44.43, lon: 26.10, timezone: 'Europe/Bucharest' },
            { name: 'Sofia', lat: 42.70, lon: 23.32, timezone: 'Europe/Sofia' },
            { name: 'Belgrade', lat: 44.82, lon: 20.46, timezone: 'Europe/Belgrade' },
            { name: 'Zagreb', lat: 45.81, lon: 15.98, timezone: 'Europe/Zagreb' },
            { name: 'Ljubljana', lat: 46.05, lon: 14.51, timezone: 'Europe/Ljubljana' },
            { name: 'Sarajevo', lat: 43.86, lon: 18.41, timezone: 'Europe/Sarajevo' },
            { name: 'Skopje', lat: 42.00, lon: 21.43, timezone: 'Europe/Skopje' },
            { name: 'Tirana', lat: 41.33, lon: 19.82, timezone: 'Europe/Tirane' },
            { name: 'Valletta', lat: 35.90, lon: 14.51, timezone: 'Europe/Malta' },
            { name: 'Nicosia', lat: 35.17, lon: 33.37, timezone: 'Asia/Nicosia' },
            { name: 'Luxembourg', lat: 49.61, lon: 6.13, timezone: 'Europe/Luxembourg' },
            { name: 'Monaco', lat: 43.73, lon: 7.42, timezone: 'Europe/Monaco' },
            { name: 'Andorra la Vella', lat: 42.51, lon: 1.52, timezone: 'Europe/Andorra' }
        ];

        // ── World Map Overlay ──────────────────────────────────────────
        let worldMapPolygons = null; // Cached decoded polygons
        let mapFadeTimeout = null;
        let mapClearTimeout = null;
        let currentMapBounds = null; // Stored for click-to-coordinate conversion
        let currentMapLat = null;    // Last displayed dot latitude
        let currentMapLon = null;    // Last displayed dot longitude
        let currentExtraDots = null; // Array of {lat, lon, color} for similar cities

        // Heatmap overlay state
        let heatmapGridCache = {};     // dateStr → 2D array [row][col] of tempC
        let currentHeatmapGrid = null; // currently loaded grid data
        const HEATMAP_LAT_MIN = -60, HEATMAP_LAT_MAX = 80;
        const HEATMAP_LON_MIN = -180, HEATMAP_LON_MAX = 170;
        const HEATMAP_STEP = 10;
        const HEATMAP_ROWS = 15; // (80 - (-60)) / 10 + 1
        const HEATMAP_COLS = 36; // (170 - (-180)) / 10 + 1

        // Fetch temperature grid for heatmap overlay
        async function fetchHeatmapGrid(dateStr) {
            if (heatmapGridCache[dateStr]) return heatmapGridCache[dateStr];

            // Generate grid points
            const gridPoints = [];
            for (let row = 0; row < HEATMAP_ROWS; row++) {
                for (let col = 0; col < HEATMAP_COLS; col++) {
                    gridPoints.push({
                        lat: HEATMAP_LAT_MIN + row * HEATMAP_STEP,
                        lon: HEATMAP_LON_MIN + col * HEATMAP_STEP,
                        row, col
                    });
                }
            }

            // Choose API based on date
            const today = new Date();
            const target = new Date(dateStr + 'T00:00:00');
            const diffDays = Math.round((target - today) / (1000 * 60 * 60 * 24));
            const isHistorical = diffDays < -5;
            const baseUrl = isHistorical
                ? 'https://archive-api.open-meteo.com/v1/archive'
                : 'https://api.open-meteo.com/v1/forecast';

            // Batch into groups of 50
            const batchSize = 50;
            const batches = [];
            for (let i = 0; i < gridPoints.length; i += batchSize) {
                batches.push(gridPoints.slice(i, i + batchSize));
            }

            // Initialize result grid
            const grid = [];
            for (let r = 0; r < HEATMAP_ROWS; r++) {
                grid.push(new Array(HEATMAP_COLS).fill(null));
            }

            // Fetch all batches in parallel
            const batchResults = await Promise.all(batches.map(async (batch) => {
                try {
                    const lats = batch.map(p => p.lat).join(',');
                    const lons = batch.map(p => p.lon).join(',');
                    const url = `${baseUrl}?latitude=${lats}&longitude=${lons}&hourly=temperature_2m,is_day&start_date=${dateStr}&end_date=${dateStr}&timezone=auto`;
                    const resp = await fetch(url);
                    return { status: 'fulfilled', value: { batch, json: await resp.json() } };
                } catch (e) {
                    return { status: 'rejected' };
                }
            }));

            batchResults.forEach(result => {
                if (result.status === 'fulfilled') {
                    const { batch, json } = result.value;
                    const items = Array.isArray(json) ? json : [json];
                    items.forEach((item, idx) => {
                        const pt = batch[idx];
                        if (item.hourly && item.hourly.temperature_2m && item.hourly.is_day) {
                            let s = 0, c = 0;
                            for (let h = 0; h < item.hourly.temperature_2m.length; h++) {
                                if (item.hourly.is_day[h]) {
                                    s += item.hourly.temperature_2m[h];
                                    c++;
                                }
                            }
                            if (c > 0) {
                                grid[pt.row][pt.col] = s / c;
                            } else {
                                // All hours are night (polar), use overall mean
                                const temps = item.hourly.temperature_2m.filter(t => t !== null);
                                if (temps.length > 0) {
                                    grid[pt.row][pt.col] = temps.reduce((a, b) => a + b, 0) / temps.length;
                                }
                            }
                        }
                    });
                }
            });

            heatmapGridCache[dateStr] = grid;
            return grid;
        }

        // Fetch and decode TopoJSON country data (110m simplified from Natural Earth)
        async function fetchWorldMapData() {
            if (worldMapPolygons) return worldMapPolygons;
            try {
                const resp = await fetch('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
                const topo = await resp.json();
                worldMapPolygons = decodeTopoJSON(topo);
                return worldMapPolygons;
            } catch (e) {
                console.error('Failed to fetch world map data:', e);
                return null;
            }
        }

        // Decode TopoJSON to arrays of [lon, lat] polygon rings
        function decodeTopoJSON(topo) {
            const { scale, translate } = topo.transform;
            // Decode arcs: delta-encoded integers → absolute lon/lat
            const arcs = topo.arcs.map(arc => {
                let x = 0, y = 0;
                return arc.map(([dx, dy]) => {
                    x += dx; y += dy;
                    return [x * scale[0] + translate[0], y * scale[1] + translate[1]];
                });
            });
            // Extract polygon rings from country geometries
            const countries = topo.objects.countries;
            const polygons = [];
            function extractGeometry(geom) {
                if (geom.type === 'GeometryCollection') {
                    geom.geometries.forEach(extractGeometry);
                } else if (geom.type === 'Polygon') {
                    geom.arcs.forEach(ring => polygons.push(resolveRing(ring)));
                } else if (geom.type === 'MultiPolygon') {
                    geom.arcs.forEach(poly => poly.forEach(ring => polygons.push(resolveRing(ring))));
                }
            }
            function resolveRing(ring) {
                const coords = [];
                ring.forEach(idx => {
                    const arc = idx < 0 ? [...arcs[~idx]].reverse() : arcs[idx];
                    arc.forEach((pt, i) => {
                        if (i > 0 || coords.length === 0) coords.push(pt);
                    });
                });
                return coords;
            }
            extractGeometry(countries);
            return polygons;
        }

        // Equirectangular projection: lon/lat → canvas x/y
        // Clipped to 83°N – 60°S (excludes Antarctica)
        const MAP_LAT_TOP = 83;
        const MAP_LAT_BOTTOM = -60;
        function projectGeo(lon, lat, mapBounds) {
            const x = mapBounds.left + ((lon + 180) / 360) * mapBounds.width;
            const y = mapBounds.top + ((MAP_LAT_TOP - lat) / (MAP_LAT_TOP - MAP_LAT_BOTTOM)) * mapBounds.height;
            return { x, y };
        }

        // Reverse projection: canvas x/y → lon/lat
        function unprojectGeo(x, y, mapBounds) {
            const lon = ((x - mapBounds.left) / mapBounds.width) * 360 - 180;
            const lat = MAP_LAT_TOP - ((y - mapBounds.top) / mapBounds.height) * (MAP_LAT_TOP - MAP_LAT_BOTTOM);
            return { lon, lat };
        }

        // Reverse geocode coordinates to get a place name and timezone
        async function reverseGeocode(lat, lon) {
            try {
                const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&zoom=10&accept-language=en`;
                const resp = await fetch(url, { headers: { 'User-Agent': 'WeatherFlow/1.0' } });
                const data = await resp.json();
                const name = data.address.city || data.address.town || data.address.village
                    || data.address.county || data.address.state || data.address.country || `${lat.toFixed(1)}°, ${lon.toFixed(1)}°`;
                return name;
            } catch (e) {
                return `${lat.toFixed(1)}°, ${lon.toFixed(1)}°`;
            }
        }

        // Draw heatmap overlay clipped to land masses
        function drawHeatmapOverlay(ctx, mapBounds, polygons, gridData) {
            // Build offscreen canvas with grid temperatures
            const offscreen = document.createElement('canvas');
            offscreen.width = HEATMAP_COLS;
            offscreen.height = HEATMAP_ROWS;
            const offCtx = offscreen.getContext('2d');
            const imgData = offCtx.createImageData(HEATMAP_COLS, HEATMAP_ROWS);

            for (let row = 0; row < HEATMAP_ROWS; row++) {
                for (let col = 0; col < HEATMAP_COLS; col++) {
                    const tempC = gridData[row][col];
                    const idx = ((HEATMAP_ROWS - 1 - row) * HEATMAP_COLS + col) * 4; // flip Y: row 0 is -60° (bottom)
                    if (tempC !== null) {
                        const color = getTempColor((tempC + 25) / 60);
                        imgData.data[idx] = Math.round(color.r);
                        imgData.data[idx + 1] = Math.round(color.g);
                        imgData.data[idx + 2] = Math.round(color.b);
                        imgData.data[idx + 3] = 140; // ~0.55 alpha
                    }
                    // null cells stay transparent (0,0,0,0)
                }
            }
            offCtx.putImageData(imgData, 0, 0);

            // Clip to land polygons
            ctx.save();
            ctx.beginPath();
            polygons.forEach(ring => {
                if (ring.length < 3) return;
                const allSouth = ring.every(pt => pt[1] < -60);
                if (allSouth) return;
                const first = projectGeo(ring[0][0], ring[0][1], mapBounds);
                ctx.moveTo(first.x, first.y);
                for (let i = 1; i < ring.length; i++) {
                    const p = projectGeo(ring[i][0], ring[i][1], mapBounds);
                    const lonJump = Math.abs(ring[i][0] - ring[i - 1][0]);
                    if (lonJump > 90) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
            });
            ctx.clip();

            // Draw the tiny heatmap stretched to map bounds with bilinear smoothing
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Map the grid's lat/lon range to canvas pixel coordinates
            const topLeft = projectGeo(HEATMAP_LON_MIN - HEATMAP_STEP / 2, HEATMAP_LAT_MAX + HEATMAP_STEP / 2, mapBounds);
            const bottomRight = projectGeo(HEATMAP_LON_MAX + HEATMAP_STEP / 2, HEATMAP_LAT_MIN - HEATMAP_STEP / 2, mapBounds);
            ctx.drawImage(offscreen, topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);

            ctx.restore();
        }

        // Draw the world map with country outlines and city marker
        // Draw country outlines + extra dots (background layer, no main city dot)
        function drawWorldMapBackground(ctx, polygons, mapBounds, extraDots, heatmapGridData) {
            // Draw heatmap underneath if active
            if (heatmapGridData) {
                drawHeatmapOverlay(ctx, mapBounds, polygons, heatmapGridData);
            }

            ctx.strokeStyle = heatmapGridData ? 'rgba(100, 130, 180, 0.5)' : 'rgba(100, 130, 180, 0.3)';
            ctx.lineWidth = 0.5;
            polygons.forEach(ring => {
                if (ring.length < 3) return;
                const allSouth = ring.every(pt => pt[1] < -60);
                if (allSouth) return;
                ctx.beginPath();
                const first = projectGeo(ring[0][0], ring[0][1], mapBounds);
                ctx.moveTo(first.x, first.y);
                for (let i = 1; i < ring.length; i++) {
                    const p = projectGeo(ring[i][0], ring[i][1], mapBounds);
                    const lonJump = Math.abs(ring[i][0] - ring[i - 1][0]);
                    if (lonJump > 90) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
                ctx.stroke();
            });
            if (extraDots && extraDots.length > 0) {
                extraDots.forEach(dot => {
                    const dp = projectGeo(dot.lon, dot.lat, mapBounds);
                    ctx.fillStyle = colorToString(dot.color, 0.7);
                    ctx.beginPath();
                    ctx.arc(dp.x, dp.y, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
        }

        // Draw the main city dot at given coordinates
        function drawCityDot(ctx, lat, lon, mapBounds) {
            const pos = projectGeo(lon, lat, mapBounds);
            let dotColor = { r: 255, g: 200, b: 140 }; // fallback warm
            if (fullWeatherData && fullWeatherData.daylight && fullWeatherData.temperature) {
                let sum = 0, count = 0;
                for (let i = 0; i < 24; i++) {
                    if (fullWeatherData.daylight[i] > 0.5) {
                        sum += fullWeatherData.temperature[i];
                        count++;
                    }
                }
                if (count > 0) dotColor = getTempColor(sum / count);
            }
            ctx.fillStyle = colorToString(dotColor, 0.9);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw full world map (background + city dot)
        function drawWorldMap(ctx, polygons, cityLat, cityLon, mapBounds, extraDots, heatmapGridData) {
            drawWorldMapBackground(ctx, polygons, mapBounds, extraDots, heatmapGridData);
            drawCityDot(ctx, cityLat, cityLon, mapBounds);
        }

        // Animate dot from one position to another on the map
        let dotAnimationId = null;
        function animateDotTransition(canvas, fromLat, fromLon, toLat, toLon, duration) {
            if (dotAnimationId) { cancelAnimationFrame(dotAnimationId); dotAnimationId = null; }
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const mapWidth = rect.width;
            const mapHeight = rect.height;

            // Draw background once and cache as ImageData
            ctx.setTransform(2, 0, 0, 2, 0, 0);
            ctx.clearRect(0, 0, mapWidth, mapHeight);
            drawWorldMapBackground(ctx, worldMapPolygons, currentMapBounds, currentExtraDots, currentHeatmapGrid);
            const baseImage = ctx.getImageData(0, 0, canvas.width, canvas.height);

            const startTime = performance.now();
            function frame(now) {
                const elapsed = now - startTime;
                const t = Math.min(1, elapsed / duration);
                const eased = 1 - Math.pow(1 - t, 3); // ease-out cubic

                const lat = fromLat + (toLat - fromLat) * eased;
                const lon = fromLon + (toLon - fromLon) * eased;

                // Restore background
                ctx.putImageData(baseImage, 0, 0);
                ctx.setTransform(2, 0, 0, 2, 0, 0);

                // Draw dot at interpolated position
                drawCityDot(ctx, lat, lon, currentMapBounds);

                if (t < 1) {
                    dotAnimationId = requestAnimationFrame(frame);
                } else {
                    dotAnimationId = null;
                }
            }
            dotAnimationId = requestAnimationFrame(frame);
        }

        // Show the world map below the UI
        async function showWorldMap(cityLat, cityLon) {
            // Cancel any existing fade timers
            if (mapFadeTimeout) { clearTimeout(mapFadeTimeout); mapFadeTimeout = null; }
            if (mapClearTimeout) { clearTimeout(mapClearTimeout); mapClearTimeout = null; }
            if (dotAnimationId) { cancelAnimationFrame(dotAnimationId); dotAnimationId = null; }

            const canvas = document.getElementById('worldMapCanvas');
            const mapAlreadyVisible = canvas.classList.contains('visible') && currentMapBounds && currentMapLat !== null;

            // Save previous position for animation
            const prevLat = currentMapLat;
            const prevLon = currentMapLon;

            // Track current dot position for resize redraw
            currentMapLat = cityLat;
            currentMapLon = cityLon;

            // Fetch heatmap grid for current date (skip if already cached for this date)
            const city = cities[currentCity];
            const dateStr = getDateForOffset(city, currentDayOffset);
            if (heatmapGridCache[dateStr]) {
                currentHeatmapGrid = heatmapGridCache[dateStr];
            } else {
                fetchHeatmapGrid(dateStr).then(grid => {
                    currentHeatmapGrid = grid;
                    // Redraw map with heatmap if still visible
                    if (canvas.classList.contains('visible') && currentMapBounds && worldMapPolygons) {
                        const ctx = canvas.getContext('2d');
                        const rect = canvas.getBoundingClientRect();
                        ctx.setTransform(2, 0, 0, 2, 0, 0);
                        ctx.clearRect(0, 0, rect.width, rect.height);
                        drawWorldMap(ctx, worldMapPolygons, currentMapLat, currentMapLon, currentMapBounds, currentExtraDots, currentHeatmapGrid);
                    }
                }).catch(e => console.error('Heatmap fetch failed:', e));
            }

            // If map is already visible, animate the dot instead of rebuilding
            if (mapAlreadyVisible) {
                animateDotTransition(canvas, prevLat, prevLon, cityLat, cityLon, 800);
                showYearBand();
                scheduleMapFadeOut(canvas);
                return;
            }

            canvas.classList.remove('visible');

            // Fetch map data (cached after first load)
            const polygons = await fetchWorldMapData();
            if (!polygons) return;

            // Size the map to match the sky ribbon width, preserving aspect ratio
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const skyRibbonEl = document.getElementById('skyRibbon');
            const wrapperRect = wrapper.getBoundingClientRect();
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const mapWidth = skyRect.width;
            const padding = 15;
            // Correct aspect ratio: 360° longitude / 143° latitude (83°N to 60°S)
            const mapAspect = 360 / (MAP_LAT_TOP - MAP_LAT_BOTTOM);
            const innerWidth = mapWidth - padding * 2;
            const idealHeight = innerWidth / mapAspect + padding * 2;
            const maxHeight = wrapperRect.height || window.innerHeight * 0.5;
            const mapHeight = Math.min(idealHeight, maxHeight);

            // Size canvas (retina)
            canvas.width = mapWidth * 2;
            canvas.height = mapHeight * 2;
            canvas.style.width = mapWidth + 'px';
            canvas.style.height = mapHeight + 'px';

            // Fit map bounds within canvas while preserving aspect ratio
            const boundsHeight = mapHeight - padding * 2;
            const boundsWidth = boundsHeight * mapAspect;
            const boundsLeft = (mapWidth - boundsWidth) / 2;
            currentMapBounds = {
                left: boundsLeft,
                top: padding,
                width: boundsWidth,
                height: boundsHeight
            };

            // Draw once (static, no animation)
            const ctx = canvas.getContext('2d');
            ctx.setTransform(2, 0, 0, 2, 0, 0);
            drawWorldMap(ctx, polygons, cityLat, cityLon, currentMapBounds, currentExtraDots, currentHeatmapGrid);

            // Fade in
            canvas.style.pointerEvents = '';
            canvas.offsetHeight; // force reflow
            canvas.classList.add('visible');
            showYearBand();

            // After 8 seconds, fade out
            scheduleMapFadeOut(canvas);
        }

        // Schedule the map fade-out timer
        function scheduleMapFadeOut(canvas, delay = 8000) {
            if (mapFadeTimeout) clearTimeout(mapFadeTimeout);
            if (mapClearTimeout) clearTimeout(mapClearTimeout);
            mapFadeTimeout = setTimeout(() => {
                // Keep clickable during the 5s fade-out
                canvas.style.pointerEvents = 'auto';
                canvas.classList.remove('visible');
                // Clean up after the 5s fade-out transition completes
                mapClearTimeout = setTimeout(() => {
                    if (dotAnimationId) { cancelAnimationFrame(dotAnimationId); dotAnimationId = null; }
                    canvas.style.pointerEvents = '';
                    currentMapBounds = null;
                    currentMapLat = null;
                    currentMapLon = null;
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    canvas.style.width = '0';
                    canvas.style.height = '0';
                    // Map fully gone — start year band fade
                    scheduleYearBandFadeOut();
                }, 5500);
            }, delay);
        }

        // Resize the map if it's currently visible
        function resizeWorldMap() {
            if (dotAnimationId) { cancelAnimationFrame(dotAnimationId); dotAnimationId = null; }
            const canvas = document.getElementById('worldMapCanvas');
            if (!canvas.classList.contains('visible') || currentMapLat === null || !worldMapPolygons) return;

            const wrapper = document.getElementById('weatherDisplayWrapper');
            const skyRibbonEl = document.getElementById('skyRibbon');
            const wrapperRect = wrapper.getBoundingClientRect();
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const mapWidth = skyRect.width;
            const padding = 15;
            const mapAspect = 360 / (MAP_LAT_TOP - MAP_LAT_BOTTOM);
            const innerWidth = mapWidth - padding * 2;
            const idealHeight = innerWidth / mapAspect + padding * 2;
            const maxHeight = wrapperRect.height || window.innerHeight * 0.5;
            const mapHeight = Math.min(idealHeight, maxHeight);

            canvas.width = mapWidth * 2;
            canvas.height = mapHeight * 2;
            canvas.style.width = mapWidth + 'px';
            canvas.style.height = mapHeight + 'px';

            const boundsHeight = mapHeight - padding * 2;
            const boundsWidth = boundsHeight * mapAspect;
            const boundsLeft = (mapWidth - boundsWidth) / 2;
            currentMapBounds = {
                left: boundsLeft,
                top: padding,
                width: boundsWidth,
                height: boundsHeight
            };

            const ctx = canvas.getContext('2d');
            ctx.setTransform(2, 0, 0, 2, 0, 0);
            drawWorldMap(ctx, worldMapPolygons, currentMapLat, currentMapLon, currentMapBounds, currentExtraDots, currentHeatmapGrid);
        }

        // Click on the map to select a location
        document.getElementById('worldMapCanvas').addEventListener('click', async (e) => {
            if (!currentMapBounds || !worldMapPolygons) return;

            const canvas = e.currentTarget;
            const rect = canvas.getBoundingClientRect();
            // CSS pixel coordinates (mapBounds uses CSS pixels, not retina)
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const { lon, lat } = unprojectGeo(x, y, currentMapBounds);

            // Clamp to valid range
            if (lat < MAP_LAT_BOTTOM || lat > MAP_LAT_TOP || lon < -180 || lon > 180) return;

            // Track new dot position for resize redraw
            currentMapLat = lat;
            currentMapLon = lon;

            // Immediately redraw map with new dot position
            const mapWidth = rect.width;
            const mapHeight = rect.height;
            const ctx = canvas.getContext('2d');
            ctx.setTransform(2, 0, 0, 2, 0, 0);
            ctx.clearRect(0, 0, mapWidth, mapHeight);
            currentExtraDots = null; // Clear similar-city dots on new location pick
            drawWorldMap(ctx, worldMapPolygons, lat, lon, currentMapBounds, null, currentHeatmapGrid);

            // Restore full visibility (in case we're mid-fade) and reset timer
            canvas.classList.add('visible');
            scheduleMapFadeOut(canvas, 15000);

            // Get place name via reverse geocoding (async, don't block UI)
            const roundedLat = Math.round(lat * 100) / 100;
            const roundedLon = Math.round(lon * 100) / 100;
            const name = await reverseGeocode(roundedLat, roundedLon);

            // Create a new city entry with auto timezone
            const cityKey = name.toLowerCase().replace(/[^a-z0-9]+/g, '-') + '-' + Date.now();
            cities[cityKey] = {
                name: name,
                lat: roundedLat,
                lon: roundedLon,
                timezone: 'auto'
            };
            currentCity = cityKey;
            currentDayOffset = 0;

            // Update weather display (skip temp range recalc now; recalcs on day change)
            await refreshView(true);
            showYearBand();
            prefetchRemainingDays(cityKey);
        });

        // Cache for fetched weather data (keyed by city-dayOffset)
        const weatherCache = {};

        // Year band data cache (keyed by cityKey)
        const yearBandCache = {};
        let yearBandCity = null; // Track which city the current band is for

        // Load saved default city from localStorage
        function loadDefaultCity() {
            try {
                const saved = localStorage.getItem('weatherFlow_defaultCity');
                if (saved) {
                    const cityData = JSON.parse(saved);
                    // Add to cities if not a built-in city
                    if (!cities[cityData.key]) {
                        cities[cityData.key] = cityData.data;
                    }
                    return cityData.key;
                }
            } catch (e) {
                console.log('Could not load saved city:', e);
            }
            return 'baltimore';
        }

        function saveDefaultCity(cityKey) {
            try {
                const cityData = {
                    key: cityKey,
                    data: cities[cityKey]
                };
                localStorage.setItem('weatherFlow_defaultCity', JSON.stringify(cityData));
            } catch (e) {
                console.log('Could not save default city:', e);
            }
        }

        // Current state
        let currentCity = loadDefaultCity();
        let currentDayOffset = 0; // 0 = today, positive = future, negative = past
        const maxFutureOffset = 14; // Today + 14 days ahead (API limit)
        const historyBatchSize = 7; // Days to prefetch when going back in time

        // Current weather data
        let fullWeatherData = null;
        let weatherData = {};

        // Helper to get date string for a given offset from today in city's timezone
        function getDateForOffset(city, dayOffset) {
            const now = new Date();
            const opts = city.timezone && city.timezone !== 'auto' ? { timeZone: city.timezone } : {};
            const cityDateStr = now.toLocaleDateString('en-CA', opts);
            const cityToday = new Date(cityDateStr + 'T00:00:00');
            const targetDate = new Date(cityToday);
            targetDate.setDate(targetDate.getDate() + dayOffset);
            return targetDate.toISOString().split('T')[0];
        }

        // Fetch weather data from Open-Meteo API (forecast or historical)
        async function fetchWeatherData(cityKey, dayOffset = 0) {
            const city = cities[cityKey];
            const dateStr = getDateForOffset(city, dayOffset);

            // Cache key uses the actual date to ensure correct data
            const cacheKey = `${cityKey}-${dateStr}`;

            // Return cached data if available and has all required fields
            if (weatherCache[cacheKey] && weatherCache[cacheKey].precipMm && weatherCache[cacheKey].snowCm) {
                return weatherCache[cacheKey];
            }

            // Use historical API for past dates (more than 5 days ago), forecast API otherwise
            // Historical API has ~5 day delay, so use forecast for recent past
            const isHistorical = dayOffset < -5;
            const baseUrl = isHistorical
                ? 'https://archive-api.open-meteo.com/v1/archive'
                : 'https://api.open-meteo.com/v1/forecast';

            // Historical API doesn't have precipitation_probability
            const hourlyParams = isHistorical
                ? 'temperature_2m,cloud_cover,rain,snowfall,precipitation,wind_speed_10m,wind_direction_10m'
                : 'temperature_2m,cloud_cover,rain,snowfall,precipitation,precipitation_probability,wind_speed_10m,wind_direction_10m,is_day';

            const url = `${baseUrl}?latitude=${city.lat}&longitude=${city.lon}&hourly=${hourlyParams}&daily=sunrise,sunset&timezone=${encodeURIComponent(city.timezone)}&start_date=${dateStr}&end_date=${dateStr}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                // Parse sunrise/sunset times to hours
                const sunriseTime = new Date(data.daily.sunrise[0]);
                const sunsetTime = new Date(data.daily.sunset[0]);
                const sunriseHour = sunriseTime.getHours() + sunriseTime.getMinutes() / 60;
                const sunsetHour = sunsetTime.getHours() + sunsetTime.getMinutes() / 60;

                // Generate daylight array based on sunrise/sunset using smooth cosine curve
                // This creates a natural bell curve for daylight intensity
                const daylight = [];
                const transitionDuration = 1.5; // hours for dawn/dusk transition
                for (let hour = 0; hour < 24; hour++) {
                    let value;
                    if (hour < sunriseHour - transitionDuration) {
                        // Full night before dawn
                        value = 0;
                    } else if (hour < sunriseHour + transitionDuration) {
                        // Dawn transition - smooth cosine curve from 0 to 1
                        const t = (hour - (sunriseHour - transitionDuration)) / (2 * transitionDuration);
                        value = 0.5 - 0.5 * Math.cos(t * Math.PI);
                    } else if (hour < sunsetHour - transitionDuration) {
                        // Full day
                        value = 1;
                    } else if (hour < sunsetHour + transitionDuration) {
                        // Dusk transition - smooth cosine curve from 1 to 0
                        const t = (hour - (sunsetHour - transitionDuration)) / (2 * transitionDuration);
                        value = 0.5 + 0.5 * Math.cos(t * Math.PI);
                    } else {
                        // Full night after dusk
                        value = 0;
                    }
                    daylight.push(value);
                }

                // Normalize cloud cover (0-100 -> 0-1)
                const clouds = data.hourly.cloud_cover.map(c => c / 100);

                // Use precipitation field as primary source (works for all forecast days)
                // precipitation = total water equivalent in mm (rain + melted snow)
                // Fall back to rain field if precipitation is not available
                const precipMm = data.hourly.precipitation || data.hourly.rain;

                // Normalize precipitation for visual rendering (mm -> 0-1, capped at 10mm = 1)
                // Use precipitation field instead of rain for consistent display across all days
                const rain = precipMm.map(p => Math.min(1, p / 10));

                // Normalize snowfall (cm -> 0-1, capped at 5cm = 1)
                const snowfall = data.hourly.snowfall.map(s => Math.min(1, s / 5));
                const hasSnow = snowfall.some(s => s > 0);
                // Keep raw snow values (cm) for display
                const snowCm = data.hourly.snowfall;

                // Normalize temperature (-25°C to 50°C+ -> 0 to 1.25)
                const temperature = data.hourly.temperature_2m.map(t => {
                    return Math.max(0, (t + 25) / 60);
                });

                // Get precipitation probability (0-100%) - keep hourly array
                const precipProbability = data.hourly.precipitation_probability || new Array(24).fill(0);

                // Wind speed (km/h) - normalize to 0-1 (0 = calm, 1 = 80+ km/h strong wind)
                const windSpeedRaw = data.hourly.wind_speed_10m || new Array(24).fill(0);
                const windSpeed = windSpeedRaw.map(w => Math.min(1, w / 80));
                // Wind direction (degrees, 0 = North, 90 = East, etc.)
                const windDirection = data.hourly.wind_direction_10m || new Array(24).fill(0);

                const weatherData = {
                    daylight,
                    clouds,
                    rain,
                    precipMm,
                    snow: hasSnow ? snowfall : null,
                    snowCm,
                    temperature,
                    precipProbability,
                    windSpeed,
                    windSpeedRaw,
                    windDirection,
                    sunriseHour,
                    sunsetHour
                };

                // Cache the result
                weatherCache[cacheKey] = weatherData;
                return weatherData;

            } catch (error) {
                console.error('Failed to fetch weather data:', error);
                const z = new Array(24).fill(0);
                return {
                    daylight: [0,0,0,0,0,0,0.1,0.4,0.7,0.9,1,1,1,1,1,1,0.9,0.5,0.1,0,0,0,0,0],
                    clouds: new Array(24).fill(0.3), rain: z, precipMm: z,
                    snow: null, snowCm: z, temperature: new Array(24).fill(0.5),
                    precipProbability: z, windSpeed: z, windSpeedRaw: z, windDirection: z,
                    sunriseHour: 6, sunsetHour: 18
                };
            }
        }

        // Find sunrise and sunset hours from daylight data
        function findSunriseSunset(daylightData) {
            let sunrise = 0, sunset = 23;
            for (let i = 0; i < daylightData.length; i++) {
                if (daylightData[i] > 0) {
                    sunrise = i;
                    break;
                }
            }
            for (let i = daylightData.length - 1; i >= 0; i--) {
                if (daylightData[i] > 0) {
                    sunset = i;
                    break;
                }
            }
            return { sunrise, sunset };
        }

        // Get display range: 2h before sunrise to 2h after sunset
        function getDisplayRange(data) {
            const { sunrise, sunset } = findSunriseSunset(data.daylight);
            const startHour = Math.max(0, sunrise - 2);
            const endHour = Math.min(23, sunset + 2);
            return { startHour, endHour };
        }

        function sliceWeatherData(data, startHour, endHour) {
            return data.slice(startHour, endHour + 1);
        }

        // Store display range for proper interpolation mapping
        let displayStartHour = 0;
        let displayEndHour = 23;

        // Store temperature display range (mean ± 10°C) for current location
        // These are normalized values (0-1 representing -25°C to +35°C)
        let tempDisplayMin = 0;  // Will be updated when location changes
        let tempDisplayMax = 1;  // Will be updated when location changes
        let tempRangeCity = null; // Track which city the temp range was calculated for
        let tempRangeBaseOffset = 0; // Track which day offset the temp range was calculated for

        // Map a normalized temperature (0-1) to display Y position fraction
        // Returns 0 at tempDisplayMin and 1 at tempDisplayMax
        function mapTempToDisplayRange(tempValue) {
            if (tempDisplayMax === tempDisplayMin) return 0.5;
            return (tempValue - tempDisplayMin) / (tempDisplayMax - tempDisplayMin);
        }

        // Calculate mean temperature across sample days for a location
        // baseOffset: the day offset to center the calculation around (0 for today, -30 for 30 days ago, etc.)
        async function calculateLocationTempRange(cityKey, baseOffset = 0) {
            let totalTemp = 0;
            let count = 0;

            // Fetch temperature data for baseOffset and baseOffset + maxFutureOffset (or just baseOffset for historical)
            const sampleDays = baseOffset >= 0
                ? [baseOffset, baseOffset + maxFutureOffset]
                : [baseOffset, baseOffset + 14]; // For historical, sample 2 weeks ahead from base

            for (const day of sampleDays) {
                try {
                    const dayData = await fetchWeatherData(cityKey, day);
                    if (dayData && dayData.temperature) {
                        // Sum all hourly temperatures
                        for (const temp of dayData.temperature) {
                            totalTemp += temp;
                            count++;
                        }
                    }
                } catch (e) {
                    // Skip days that fail to fetch
                    console.log(`Skipped day ${day} for temp range calculation`);
                }
            }

            if (count > 0) {
                const meanTemp = totalTemp / count;
                // Mean - 15°C to Mean + 22.5°C (asymmetric range, 50% larger)
                // In normalized space: 15°C = 15/60, 22.5°C = 22.5/60
                const rangeBelow = 15 / 60;
                const rangeAbove = 22.5 / 60;
                tempDisplayMin = Math.max(0, meanTemp - rangeBelow);
                tempDisplayMax = Math.min(1, meanTemp + rangeAbove);
                tempRangeBaseOffset = baseOffset;
                console.log(`Temp range for ${cityKey} (offset ${baseOffset}): mean=${((meanTemp * 60) - 25).toFixed(1)}°C, display range: ${((tempDisplayMin * 60) - 25).toFixed(1)}°C to ${((tempDisplayMax * 60) - 25).toFixed(1)}°C`);
            }
        }

        // Check if temp range needs recalculation based on day offset
        function needsTempRangeRecalc(dayOffset) {
            // Recalculate every 30 days when going back in time
            const currentBucket = Math.floor(dayOffset / 30) * 30;
            const rangeBucket = Math.floor(tempRangeBaseOffset / 30) * 30;
            return currentBucket !== rangeBucket;
        }

        // Quick temp range from a single day's data (no API calls, synchronous)
        function calculateTempRangeFromData(dayData) {
            if (!dayData || !dayData.temperature) return;
            let totalTemp = 0;
            for (const temp of dayData.temperature) {
                totalTemp += temp;
            }
            const meanTemp = totalTemp / dayData.temperature.length;
            const rangeBelow = 15 / 60;
            const rangeAbove = 22.5 / 60;
            tempDisplayMin = Math.max(0, meanTemp - rangeBelow);
            tempDisplayMax = Math.min(1, meanTemp + rangeAbove);
            tempRangeBaseOffset = 0;
        }

        // Refine temp range in background using today + day+14 data
        async function refineTempRangeInBackground(cityKey) {
            try {
                const futureData = await fetchWeatherData(cityKey, maxFutureOffset);
                const todayData = await fetchWeatherData(cityKey, 0); // cache hit
                if (!futureData || !futureData.temperature || !todayData || !todayData.temperature) return;

                let totalTemp = 0, count = 0;
                for (const t of todayData.temperature) { totalTemp += t; count++; }
                for (const t of futureData.temperature) { totalTemp += t; count++; }

                const meanTemp = totalTemp / count;
                const newMin = Math.max(0, meanTemp - 15 / 60);
                const newMax = Math.min(1, meanTemp + 22.5 / 60);

                if (Math.abs(newMin - tempDisplayMin) > 0.01 || Math.abs(newMax - tempDisplayMax) > 0.01) {
                    tempDisplayMin = newMin;
                    tempDisplayMax = newMax;
                    draw();
                }
            } catch (e) {
                // Initial range from today's data is good enough
            }
        }

        async function updateWeatherData(cityKey, dayOffset = 0) {
            fullWeatherData = await fetchWeatherData(cityKey, dayOffset);
            const { startHour, endHour } = getDisplayRange(fullWeatherData);

            // Store display range for interpolation
            displayStartHour = startHour;
            displayEndHour = endHour;

            weatherData = {
                daylight: sliceWeatherData(fullWeatherData.daylight, startHour, endHour),
                clouds: sliceWeatherData(fullWeatherData.clouds, startHour, endHour),
                rain: sliceWeatherData(fullWeatherData.rain, startHour, endHour),
                precipMm: sliceWeatherData(fullWeatherData.precipMm, startHour, endHour),
                precipProbability: sliceWeatherData(fullWeatherData.precipProbability, startHour, endHour),
                snow: fullWeatherData.snow ? sliceWeatherData(fullWeatherData.snow, startHour, endHour) : null,
                snowCm: sliceWeatherData(fullWeatherData.snowCm, startHour, endHour),
                // Keep full 24-hour temperature data for proper Catmull-Rom interpolation at edges
                temperatureFull: fullWeatherData.temperature,
                temperature: sliceWeatherData(fullWeatherData.temperature, startHour, endHour),
                windSpeed: sliceWeatherData(fullWeatherData.windSpeed, startHour, endHour),
                windSpeedRaw: sliceWeatherData(fullWeatherData.windSpeedRaw, startHour, endHour),
                windDirection: sliceWeatherData(fullWeatherData.windDirection, startHour, endHour),
                sunriseHour: fullWeatherData.sunriseHour,
                sunsetHour: fullWeatherData.sunsetHour
            };
        }

        // Get day label for display
        function getDayLabel(dayOffset) {
            if (dayOffset === 0) return 'Today';
            if (dayOffset === 1) {
                const date = new Date();
                date.setDate(date.getDate() + 1);
                const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
                return `Tomorrow ${dayName}`;
            }
            if (dayOffset === -1) {
                const date = new Date();
                date.setDate(date.getDate() - 1);
                const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
                return `Yesterday ${dayName}`;
            }

            const date = new Date();
            const currentYear = date.getFullYear();
            date.setDate(date.getDate() + dayOffset);
            // Include year if not current year
            const options = date.getFullYear() !== currentYear
                ? { weekday: 'long', month: 'short', day: 'numeric', year: 'numeric' }
                : { weekday: 'long', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Update the day label display
        function updateDayLabel() {
            document.getElementById('dayLabel').textContent = getDayLabel(currentDayOffset);
            // Past navigation is always enabled (unlimited history)
            document.getElementById('prevDay').disabled = false;
            document.getElementById('nextDay').disabled = false;
            // Also update city label
            const cityLabelEl = document.getElementById('cityLabel');
            if (cityLabelEl && cities[currentCity]) {
                cityLabelEl.textContent = cities[currentCity].name;
            }
        }

        // Loading state management
        let isLoading = false;

        function showLoading() {
            if (isLoading) return;
            isLoading = true;
            const overlay = document.getElementById('loadingOverlay');
            const loadingCurve = document.getElementById('loadingCurve');

            // Position the loading curve to match temperature curve area
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const skyRibbonEl = document.getElementById('skyRibbon');
            if (skyRibbonEl && wrapper) {
                const wrapperRect = wrapper.getBoundingClientRect();
                const skyRect = skyRibbonEl.getBoundingClientRect();
                const skyBottomInWrapper = skyRect.bottom - wrapperRect.top;
                loadingCurve.style.top = `${skyBottomInWrapper - 40}px`;
            } else {
                loadingCurve.style.top = '180px';
            }

            overlay.classList.add('visible');
        }

        function hideLoading() {
            isLoading = false;
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('visible');
        }

        // Check if weather data is already cached for a given city and day
        function isDataCached(cityKey, dayOffset) {
            const city = cities[cityKey];
            const dateStr = getDateForOffset(city, dayOffset);
            const cacheKey = `${cityKey}-${dateStr}`;
            return weatherCache[cacheKey] && weatherCache[cacheKey].precipMm && weatherCache[cacheKey].snowCm;
        }

        // Prefetch weather data in the background
        let prefetchInProgress = false;
        let prefetchedCity = null;
        let prefetchedPastBoundary = 0; // Track how far back we've prefetched

        // Prefetch future days (1 to maxFutureOffset)
        async function prefetchFutureDays(cityKey) {
            const batchSize = 3;
            for (let i = 1; i <= maxFutureOffset; i += batchSize) {
                if (prefetchedCity !== cityKey) break;
                const batch = [];
                for (let j = i; j < Math.min(i + batchSize, maxFutureOffset + 1); j++) {
                    if (!isDataCached(cityKey, j)) {
                        batch.push(fetchWeatherData(cityKey, j));
                    }
                }
                if (batch.length > 0) {
                    await Promise.all(batch);
                }
            }
        }

        // Prefetch past days in batches when user navigates backward
        async function prefetchPastDays(cityKey, fromOffset) {
            // Prefetch a batch of days before the current position
            const endOffset = fromOffset;
            const startOffset = fromOffset - historyBatchSize;

            const batch = [];
            for (let j = startOffset; j < endOffset; j++) {
                if (!isDataCached(cityKey, j)) {
                    batch.push(fetchWeatherData(cityKey, j));
                }
            }
            if (batch.length > 0) {
                await Promise.all(batch);
            }

            // Update boundary tracker
            if (startOffset < prefetchedPastBoundary) {
                prefetchedPastBoundary = startOffset;
            }
        }

        // Initial prefetch for future days
        async function prefetchRemainingDays(cityKey) {
            if (prefetchInProgress && prefetchedCity === cityKey) return;
            prefetchInProgress = true;
            prefetchedCity = cityKey;
            prefetchedPastBoundary = 0; // Reset past boundary for new city

            await prefetchFutureDays(cityKey);

            if (prefetchedCity === cityKey) {
                prefetchInProgress = false;
            }
        }

        // Refresh the current view
        // skipTempRangeRecalc: if true, keeps the current temperature bar range unchanged
        async function refreshView(skipTempRangeRecalc = false) {
            // Check if temp range needs recalculation
            const needsTempRecalc = !skipTempRangeRecalc && (tempRangeCity !== currentCity || needsTempRangeRecalc(currentDayOffset));
            // Only show loading if data isn't already cached
            const needsLoading = !isDataCached(currentCity, currentDayOffset) || needsTempRecalc;
            if (needsLoading) {
                showLoading();
            }
            try {
                // Recalculate temperature display range when city changes or every 30 days back
                if (needsTempRecalc) {
                    const baseOffset = Math.floor(currentDayOffset / 30) * 30;
                    await calculateLocationTempRange(currentCity, baseOffset);
                    tempRangeCity = currentCity;
                }
                await updateWeatherData(currentCity, currentDayOffset);
                updateDayLabel();
                draw();

                // Fetch year band data when city changes (non-blocking)
                if (yearBandCity !== currentCity) {
                    yearBandCity = currentCity;
                    fetchYearBandData(currentCity).then(() => drawYearBand());
                }

                // Update heatmap if map is visible and day changed (non-blocking)
                const mapCanvas = document.getElementById('worldMapCanvas');
                if (mapCanvas.classList.contains('visible') && currentMapBounds) {
                    const city = cities[currentCity];
                    const dateStr = getDateForOffset(city, currentDayOffset);
                    if (heatmapGridCache[dateStr]) {
                        currentHeatmapGrid = heatmapGridCache[dateStr];
                        if (worldMapPolygons) resizeWorldMap();
                    } else {
                        fetchHeatmapGrid(dateStr).then(grid => {
                            currentHeatmapGrid = grid;
                            if (mapCanvas.classList.contains('visible') && currentMapBounds && worldMapPolygons) {
                                resizeWorldMap();
                            }
                        });
                    }
                }
            } finally {
                if (needsLoading) {
                    hideLoading();
                }
            }
        }

        // Smooth interpolation function
        function smoothstep(edge0, edge1, x) {
            const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
            return t * t * (3 - 2 * t);
        }

        // Basic interpolation for most data
        function interpolateData(data, t) {
            const len = data.length;
            const idx = t * (len - 1);
            const i0 = Math.floor(idx);
            const i1 = Math.min(i0 + 1, len - 1);
            const frac = idx - i0;
            return data[i0] + (data[i1] - data[i0]) * smoothstep(0, 1, frac);
        }

        // Catmull-Rom spline interpolation for smooth curves
        // For temperature data with useFullTemperatureData=true, uses full 24-hour data
        // to avoid edge flattening at display boundaries
        function interpolateDataSmooth(data, t, useFullTemperatureData = false) {
            // For temperature: use full 24-hour data with hour-based indexing
            if (useFullTemperatureData && weatherData.temperatureFull) {
                const fullData = weatherData.temperatureFull;

                // Map t (0-1 over display range) to actual hour in 24-hour data
                const displayHours = displayEndHour - displayStartHour;
                const hour = displayStartHour + t * displayHours;

                // Catmull-Rom needs 4 control points around the target hour
                // Use proper indexing into full 24-hour array
                const i1 = Math.min(23, Math.max(0, Math.floor(hour)));
                const i0 = Math.max(0, i1 - 1);
                const i2 = Math.min(23, i1 + 1);
                const i3 = Math.min(23, i1 + 2);
                const frac = hour - i1;

                // Get temperature values at these hours
                const p0 = fullData[i0];
                const p1 = fullData[i1];
                const p2 = fullData[i2];
                const p3 = fullData[i3];

                // Catmull-Rom spline formula with tension=0.5 (standard)
                const tt = frac * frac;
                const ttt = tt * frac;

                return 0.5 * (
                    (2 * p1) +
                    (-p0 + p2) * frac +
                    (2 * p0 - 5 * p1 + 4 * p2 - p3) * tt +
                    (-p0 + 3 * p1 - 3 * p2 + p3) * ttt
                );
            }

            // For other data: use array-index-based interpolation
            const len = data.length;
            if (len < 2) return data[0] || 0;

            const idx = t * (len - 1);
            const i1 = Math.min(len - 1, Math.max(0, Math.floor(idx)));
            const i0 = Math.max(0, i1 - 1);
            const i2 = Math.min(len - 1, i1 + 1);
            const i3 = Math.min(len - 1, i1 + 2);
            const frac = idx - i1;

            const p0 = data[i0];
            const p1 = data[i1];
            const p2 = data[i2];
            const p3 = data[i3];

            // Catmull-Rom spline formula
            const tt = frac * frac;
            const ttt = tt * frac;

            return 0.5 * (
                (2 * p1) +
                (-p0 + p2) * frac +
                (2 * p0 - 5 * p1 + 4 * p2 - p3) * tt +
                (-p0 + 3 * p1 - 3 * p2 + p3) * ttt
            );
        }

        // Color interpolation
        function lerpColor(color1, color2, t) {
            return {
                r: color1.r + (color2.r - color1.r) * t,
                g: color1.g + (color2.g - color1.g) * t,
                b: color1.b + (color2.b - color1.b) * t
            };
        }

        function colorToString(c, alpha = 1) {
            return `rgba(${Math.round(c.r)}, ${Math.round(c.g)}, ${Math.round(c.b)}, ${alpha})`;
        }

        // Noise function for organic feel
        function noise(x, y, seed = 0) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
            return n - Math.floor(n);
        }

        // Calculate maximum rain height needed for the visualization
        function calculateMaxRainHeight() {
            let maxRain = 0;
            for (let i = 0; i < weatherData.rain.length; i++) {
                if (weatherData.rain[i] > maxRain) {
                    maxRain = weatherData.rain[i];
                }
            }
            return maxRain;
        }

        // Calculate maximum snow intensity
        function calculateMaxSnow() {
            if (!weatherData.snow) return 0;
            let maxSnow = 0;
            for (let i = 0; i < weatherData.snow.length; i++) {
                if (weatherData.snow[i] > maxSnow) {
                    maxSnow = weatherData.snow[i];
                }
            }
            return maxSnow;
        }

        // Sky colors: [top, bottom] for each phase
        const skyPalette = {
            black: {r:3,g:3,b:8}, night: [{r:12,g:18,b:38},{r:20,g:30,b:55}],
            twilight: [{r:55,g:45,b:85},{r:85,g:65,b:105}], dawn: [{r:255,g:130,b:90},{r:255,g:175,b:130}],
            day: [{r:85,g:170,b:235},{r:150,g:205,b:250}], noon: [{r:120,g:195,b:255},{r:170,g:220,b:255}]
        };

        function getSkyColor(dayValue, cloudValue = 1) {
            const {black, night, twilight, dawn, day, noon} = skyPalette;
            const s = (a,b,v) => smoothstep(a,b,dayValue);
            let top = lerpColor(night[0], twilight[0], s(0,0.2));
            let bottom = lerpColor(night[1], twilight[1], s(0,0.2));
            top = lerpColor(top, dawn[0], s(0.1,0.4)); bottom = lerpColor(bottom, dawn[1], s(0.1,0.4));
            top = lerpColor(top, day[0], s(0.3,0.65)); bottom = lerpColor(bottom, day[1], s(0.3,0.65));
            top = lerpColor(top, noon[0], s(0.55,0.9)); bottom = lerpColor(bottom, noon[1], s(0.55,0.9));
            const blackBlend = (1 - smoothstep(0,0.35,dayValue)) * (1 - smoothstep(0,0.08,cloudValue));
            if (blackBlend > 0) { top = lerpColor(top, black, blackBlend); bottom = lerpColor(bottom, black, blackBlend); }
            return { top, bottom };
        }

        // Unified Sky Ribbon with day/night cycle, clouds, and rain
        // Shows only the bottom three-quarters (omits upper star region at night)
        function drawSkyRibbon() {
            const canvas = document.getElementById('skyRibbon');
            const wrapper = canvas.parentElement;

            // Calculate dimensions
            const fullBaseHeight = 240; // Full height for the sky/cloud portion (doubled)
            const skyExtensionHeight = 36; // Sky gradient fade distance (reduced by 40%)
            const precipExtensionHeight = 200; // Rain/snow extends down over page background
            const fullTotalHeight = fullBaseHeight + precipExtensionHeight;

            // Crop top portion of the sky (removes cloud puffs, shows only lower sky gradient)
            const cropAmount = fullBaseHeight * 0.55;
            const visibleHeight = fullTotalHeight - cropAmount;
            const maxRain = calculateMaxRainHeight();

            // Set wrapper and canvas height to cropped size
            wrapper.style.height = visibleHeight + 'px';

            const ctx = canvas.getContext('2d');
            const width = wrapper.offsetWidth;
            canvas.width = width * 2;
            canvas.height = visibleHeight * 2;
            ctx.scale(2, 2);

            // We'll draw as if starting from cropAmount, so adjust all Y coordinates
            // by translating the context up
            ctx.translate(0, -cropAmount);

            const height = fullTotalHeight;
            const skyHeight = fullBaseHeight;

            // Cloud base position - clouds start at top and extend down
            const cloudBottomY = skyHeight * 0.5; // Bottom edge of cloud layer
            // Sky gradient fades out within the shorter sky extension area
            const skyFadeEndY = fullBaseHeight + skyExtensionHeight;

            // First, draw the sky color that extends DOWN from the cloud bottom
            // Sky fades out within skyFadeEndY, not the full height
            for (let x = 0; x < width; x++) {
                const t = x / width;
                const dayValue = interpolateData(weatherData.daylight, t);
                const cloudValue = interpolateData(weatherData.clouds, t);
                const skyColors = getSkyColor(dayValue, cloudValue);

                // Calculate sky color blended with grey based on cloud coverage
                // Use cosine interpolation for smooth brightness transitions
                const greyColor = { r: 180, g: 185, b: 195 };
                const cloudBlend = 0.5 * (1 - Math.cos(cloudValue * Math.PI));
                const skyColor = lerpColor(skyColors.bottom, greyColor, cloudBlend);

                // Create gradient from cloud bottom down, fading to transparent with cosine decay
                const gradient = ctx.createLinearGradient(x, cloudBottomY, x, skyFadeEndY);
                const numStops = 10;
                for (let i = 0; i <= numStops; i++) {
                    const t = i / numStops;
                    // Cosine decay: starts at 1, smoothly decays to 0
                    const alpha = 0.5 * (1 + Math.cos(t * Math.PI));
                    gradient.addColorStop(t, colorToString(skyColor, alpha));
                }

                ctx.fillStyle = gradient;
                ctx.fillRect(x, cloudBottomY, 1.5, skyFadeEndY - cloudBottomY);
            }

            // Draw cloud layer at the TOP of the ribbon
            for (let x = 0; x < width; x++) {
                const t = x / width;
                const cloudValue = interpolateData(weatherData.clouds, t);
                const rainValue = interpolateData(weatherData.rain, t);
                const dayValue = interpolateData(weatherData.daylight, t);

                // Use cosine interpolation for smooth cloud coverage transitions
                const cloudSmooth = 0.5 * (1 - Math.cos(cloudValue * Math.PI));

                // Calculate cloud color based on time of day using smooth transitions
                // Night clouds (dark), twilight clouds (medium), day clouds (bright)
                const nightGray = 60 - cloudSmooth * 20 - rainValue * 20;
                const dayGray = 230 - cloudSmooth * 30 - rainValue * 40;
                // Smooth transition using smoothstep for continuous blending
                const dayBlend = smoothstep(0.15, 0.55, dayValue);
                const baseGray = nightGray + (dayGray - nightGray) * dayBlend;

                // Add color tint for dawn/dusk using smooth gaussian-like curve
                let r = baseGray, g = baseGray, b = baseGray;
                // Peak tint at dayValue=0.35, smooth falloff in both directions
                const tintCenter = 0.35;
                const tintWidth = 0.2;
                const tintDist = Math.abs(dayValue - tintCenter) / tintWidth;
                const tintStrength = Math.max(0, 1 - tintDist * tintDist); // Smooth quadratic falloff
                r = Math.min(255, baseGray + 40 * tintStrength);
                g = Math.min(255, baseGray + 15 * tintStrength);
                b = Math.max(0, baseGray - 10 * tintStrength);

                // Fill the top area with cloud color (only visible when there are clouds)
                // Use cosine-smoothed alpha for gradual transitions
                const alpha = cloudSmooth;

                // Skip drawing if no clouds (fully transparent)
                if (alpha < 0.01) continue;

                const gradient = ctx.createLinearGradient(x, 0, x, cloudBottomY + 20);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b + 5}, ${alpha})`);
                gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b + 5}, ${alpha * 0.95})`);
                gradient.addColorStop(0.85, `rgba(${r - 5}, ${g - 3}, ${b}, ${alpha * 0.7})`);
                gradient.addColorStop(1, `rgba(${r - 10}, ${g - 5}, ${b - 5}, 0)`);

                ctx.fillStyle = gradient;
                ctx.fillRect(x, 0, 1.5, cloudBottomY + 20);

                // Add cloud texture/puffs at the bottom edge of the cloud layer
                const puffFreq = 0.02;
                for (let i = 0; i < 6; i++) {
                    const puffX = x + noise(x * puffFreq, i) * 15;
                    const puffY = cloudBottomY - 10 + noise(x, i) * 25;
                    const puffSize = (12 + noise(x, i * 2) * 20) * cloudSmooth;

                    if (puffSize > 3) {
                        const puffAlpha = Math.min(0.9, cloudSmooth * 0.8);
                        const puffGradient = ctx.createRadialGradient(puffX, puffY, 0, puffX, puffY, puffSize);
                        puffGradient.addColorStop(0, `rgba(${r + 10}, ${g + 10}, ${b + 15}, ${puffAlpha})`);
                        puffGradient.addColorStop(0.5, `rgba(${r}, ${g + 3}, ${b + 8}, ${puffAlpha * 0.7})`);
                        puffGradient.addColorStop(1, `rgba(${r - 10}, ${g - 5}, ${b}, 0)`);

                        ctx.fillStyle = puffGradient;
                        ctx.beginPath();
                        ctx.arc(puffX, puffY, puffSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw night sky darkening overlay - limited to sky portion (skyFadeEndY)
            for (let x = 0; x < width; x++) {
                const t = x / width;
                const dayValue = interpolateData(weatherData.daylight, t);
                const cloudValue = interpolateData(weatherData.clouds, t);

                // Night darkness intensity - stronger at night, fades during twilight
                const nightness = 1 - smoothstep(0.0, 0.4, dayValue);

                if (nightness > 0.01) {
                    // Dark blue-black overlay for night sky
                    // Use cosine interpolation for smooth cloud-based darkness transitions
                    // More clouds = darker (blocks light pollution), fewer clouds = slightly lighter
                    const cloudSmooth = 0.5 * (1 - Math.cos(cloudValue * Math.PI));
                    // Darkness ranges from 0.6 (clear) to 0.95 (overcast) smoothly
                    const darkness = nightness * (0.6 + cloudSmooth * 0.35);

                    // Create gradient from top to skyFadeEndY (sky portion only, not precipitation area)
                    const gradient = ctx.createLinearGradient(x, cropAmount, x, skyFadeEndY);
                    gradient.addColorStop(0, `rgba(5, 8, 20, ${darkness})`);
                    gradient.addColorStop(0.5, `rgba(8, 12, 28, ${darkness * 0.85})`);
                    gradient.addColorStop(0.85, `rgba(10, 15, 35, ${darkness * 0.5})`);
                    gradient.addColorStop(1, `rgba(12, 18, 40, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, cropAmount, 1.5, skyFadeEndY - cropAmount);
                }
            }

            // Draw stars at night - pre-generated random positions for natural distribution
            const starCount = 400;
            const skyAreaHeight = skyFadeEndY - cropAmount;
            // Star color palette: mostly white, some with subtle tints
            const starColors = [
                {r:255,g:255,b:255}, {r:255,g:255,b:255}, {r:255,g:255,b:255}, {r:255,g:255,b:255}, // white (common)
                {r:255,g:240,b:220}, {r:255,g:235,b:210}, // warm white/yellow
                {r:220,g:235,b:255}, {r:200,g:220,b:255}, // cool white/blue
                {r:255,g:220,b:210}, {r:255,g:200,b:180}  // warm/reddish
            ];
            for (let i = 0; i < starCount; i++) {
                const starX = noise(i * 7.3, 0) * width;
                const starY = cropAmount + noise(i * 13.7, 1) * skyAreaHeight;

                const t = starX / width;
                const dayValue = interpolateData(weatherData.daylight, t);
                const cloudValue = interpolateData(weatherData.clouds, t);
                const starVisibility = 1 - smoothstep(0.0, 0.35, dayValue);
                const cloudFade = 1 - smoothstep(0.3, 0.7, cloudValue);
                const combinedVisibility = starVisibility * cloudFade;

                if (combinedVisibility > 0.01) {
                    const size = 0.4 + noise(i, 2) * 1.0;
                    const brightness = 0.3 + noise(i, 3) * 0.7;
                    const color = starColors[Math.floor(noise(i, 4) * starColors.length)];
                    ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${combinedVisibility * brightness})`;
                    ctx.beginPath();
                    ctx.arc(starX, starY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw rain falling from clouds (only where there's rain)
            // Rain extends over page background - realistic streaks with depth layers
            if (maxRain > 0) {
                // Multiple depth layers for parallax effect - closer drops are larger and more opaque
                const dropLayers = [
                    { count: 500, size: 0.8, opacity: 0.25, lengthMult: 0.7 },   // Far background
                    { count: 400, size: 1.2, opacity: 0.4, lengthMult: 0.85 },   // Mid background
                    { count: 300, size: 1.8, opacity: 0.55, lengthMult: 1.0 },   // Mid foreground
                    { count: 200, size: 2.5, opacity: 0.7, lengthMult: 1.15 }    // Close foreground
                ];

                // Slight angle for wind-driven rain (about 10-12 degrees from vertical)
                const rainAngle = 0.18; // x offset per y unit

                dropLayers.forEach((layer, layerIdx) => {
                    for (let i = 0; i < layer.count; i++) {
                        const baseX = (noise(i, layerIdx) * width);
                        const t = baseX / width;
                        const rainValue = interpolateData(weatherData.rain, t);

                        // Skip rain if there's snow at this position (show only snow)
                        const snowValue = weatherData.snow ? interpolateData(weatherData.snow, t) : 0;
                        if (snowValue > 0.05) continue;

                        if (rainValue > 0.02 && noise(i * 2, layerIdx) < rainValue) {
                            // Slight horizontal spread for natural variation
                            const x = baseX + noise(i, layerIdx + 10) * 20 - 10;

                            // Rain falls from clouds down through extended precipitation area
                            const rainStartY = cropAmount + 20;
                            const rainEndY = skyHeight + rainValue * precipExtensionHeight;
                            const y = rainStartY + noise(i, layerIdx + 20) * (rainEndY - rainStartY);

                            // Drop length varies with rain intensity and layer depth
                            const baseLength = 8 + rainValue * 18;
                            const dropLength = baseLength * layer.lengthMult;

                            if (dropLength > 4) {
                                // Calculate end position with slight angle
                                const endX = x + dropLength * rainAngle;
                                const endY = y + dropLength;

                                // Gradient rain streak - brighter at top, fading at bottom
                                const gradient = ctx.createLinearGradient(x, y, endX, endY);
                                const r = 160, g = 195, b = 255;
                                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${layer.opacity * 0.3})`);
                                gradient.addColorStop(0.2, `rgba(${r}, ${g}, ${b}, ${layer.opacity})`);
                                gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, ${layer.opacity * 0.6})`);
                                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                                ctx.strokeStyle = gradient;
                                ctx.lineWidth = layer.size;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(endX, endY);
                                ctx.stroke();
                            }
                        }
                    }
                });

            }

            // Draw snow falling from clouds (only where there's snow)
            // Snow extends over page background - soft glowing flakes with depth
            const maxSnow = calculateMaxSnow();
            if (maxSnow > 0) {
                // Multiple depth layers for parallax - closer flakes larger and brighter
                const snowLayers = [
                    { count: 400, size: 1.0, opacity: 0.3, blur: 0.5 },   // Far background - tiny, dim
                    { count: 350, size: 1.8, opacity: 0.5, blur: 0.3 },   // Mid background
                    { count: 300, size: 2.8, opacity: 0.7, blur: 0.2 },   // Mid foreground
                    { count: 200, size: 4.0, opacity: 0.9, blur: 0 }      // Close foreground - large, bright
                ];

                snowLayers.forEach((layer, layerIdx) => {
                    for (let i = 0; i < layer.count; i++) {
                        const baseX = noise(i, layerIdx + 50) * width;
                        const t = baseX / width;
                        const snowValue = interpolateData(weatherData.snow, t);

                        if (snowValue > 0.05 && noise(i * 3, layerIdx + 60) < snowValue) {
                            // Snowflakes drift sideways with gentle wave pattern
                            const driftPhase = noise(i, layerIdx + 70) * Math.PI * 2;
                            const driftAmount = 12 + noise(i * 2, layerIdx) * 10;
                            const drift = Math.sin(driftPhase) * driftAmount;
                            const x = baseX + drift;

                            // Snow falls from clouds down through extended precipitation area
                            const snowStartY = cropAmount + 20;
                            const snowEndY = skyHeight + snowValue * precipExtensionHeight;
                            const y = snowStartY + noise(i, layerIdx + 80) * (snowEndY - snowStartY);

                            // Size varies slightly per flake
                            const sizeVariation = 0.7 + noise(i, layerIdx + 90) * 0.6;
                            const flakeSize = layer.size * sizeVariation;

                            // Draw snowflake with soft radial gradient for glow effect
                            const gradient = ctx.createRadialGradient(x, y, 0, x, y, flakeSize);
                            gradient.addColorStop(0, `rgba(255, 255, 255, ${layer.opacity})`);
                            gradient.addColorStop(0.4, `rgba(240, 248, 255, ${layer.opacity * 0.7})`);
                            gradient.addColorStop(0.8, `rgba(220, 235, 255, ${layer.opacity * 0.3})`);
                            gradient.addColorStop(1, `rgba(200, 220, 255, 0)`);

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(x, y, flakeSize * 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
            }

        }

        // Temperature color mapping (global for tooltip use)
        // Temperature colors: refined palette
        // white (freezing) → blue (cold) → yellow (mild) → orange (warm) → red (hot) → dark red (extreme)
        const tempColors = {
            white: { r: 230, g: 240, b: 255 },      // <=0°C - icy white
            blue: { r: 80, g: 160, b: 230 },        // 10°C - cool blue
            yellow: { r: 255, g: 220, b: 80 },      // 20°C - warm golden
            orange: { r: 255, g: 145, b: 70 },      // 30°C - warm orange
            red: { r: 235, g: 70, b: 55 },          // 40°C - vivid red
            darkRed: { r: 160, g: 30, b: 30 },      // 50°C - dark red
            deepMaroon: { r: 90, g: 10, b: 40 }     // >50°C - deep maroon
        };
        // Temperature thresholds (normalized: (temp + 25) / 60)
        const tempThresholds = {
            minusTen: (-10 + 25) / 60,  // -10°C = 0.25
            zero: (0 + 25) / 60,        // 0°C = 0.417
            ten: (10 + 25) / 60,        // 10°C = 0.583
            twenty: (20 + 25) / 60,     // 20°C = 0.75
            thirty: (30 + 25) / 60,     // 30°C = 0.917
            forty: (40 + 25) / 60,      // 40°C = 1.083
            fifty: (50 + 25) / 60       // 50°C = 1.25
        };

        function getTempColor(tempValue) {
            const { white, blue, yellow, orange, red, darkRed, deepMaroon } = tempColors;
            const { minusTen, zero, ten, twenty, thirty, forty, fifty } = tempThresholds;

            if (tempValue < zero) return white;  // <=0°C: solid white (dashed handled separately)
            if (tempValue < ten) return lerpColor(white, blue, (tempValue - zero) / (ten - zero));
            if (tempValue < twenty) return lerpColor(blue, yellow, (tempValue - ten) / (twenty - ten));
            if (tempValue < thirty) return lerpColor(yellow, orange, (tempValue - twenty) / (thirty - twenty));
            if (tempValue < forty) return lerpColor(orange, red, (tempValue - thirty) / (forty - thirty));
            if (tempValue < fifty) return lerpColor(red, darkRed, (tempValue - forty) / (fifty - forty));
            return deepMaroon;  // >50°C: deep maroon
        }

        // Check if temperature should be drawn dashed (below 0°C)
        function isTempDashed(tempValue) {
            return tempValue < tempThresholds.zero;
        }

        // Get dash pattern based on temperature (longer gaps as it gets colder)
        // Returns [dashLength, gapLength] or null for continuous line
        function getTempDashPattern(tempValue) {
            const { zero, minusTen } = tempThresholds;
            const minusOne = (-1 + 25) / 60;

            if (tempValue >= minusOne) return null; // Continuous at 0°C to -1°C

            // Calculate how far below -1°C (0 at -1°C, 1 at -10°C or below)
            const coldness = Math.min(1, (minusOne - tempValue) / (minusOne - minusTen));

            // Dash length stays constant, gap increases with coldness
            const dashLength = 10;
            const minGap = 4;   // Gap just below -1°C
            const maxGap = 10;  // Gap at -10°C or below
            const gapLength = minGap + coldness * (maxGap - minGap);

            return [dashLength, gapLength];
        }

        function getDaylightBrightness(dayValue) {
            return 0.05 + 0.95 * smoothstep(0.1, 0.65, dayValue);
        }

        // Temperature Curve on page background
        function drawTemperatureCurve() {
            const canvas = document.getElementById('tempCurveCanvas');
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const skyRibbonEl = document.getElementById('skyRibbon');
            const ctx = canvas.getContext('2d');

            // Get wrapper and sky ribbon dimensions for relative positioning
            const wrapperRect = wrapper.getBoundingClientRect();
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const width = window.innerWidth;
            const height = wrapperRect.height || window.innerHeight * 0.6;

            // Calculate sky ribbon position relative to wrapper
            const skyBottomInWrapper = (skyRect.bottom - wrapperRect.top);

            // Set canvas to wrapper size
            canvas.width = width * 2;
            canvas.height = height * 2;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(2, 2);

            // Draw the temperature curve with gradient fill
            const curveHeight = Math.min(height * 0.396, 216); // Curve height, capped (50% taller)
            // The reference line top is at curveBottom - (maxTempNorm * curveHeight * 0.8)
            // where maxTempNorm = (45 + 25) / 60 = 1.167 (clamped to ~1)
            // So reference line top offset from curveBottom is about curveHeight * 0.8
            // We want that point to be at skyBottomInWrapper, then shift up 200px
            const curveBottom = skyBottomInWrapper + curveHeight * 0.8 - 160;
            const curveTop = curveBottom - curveHeight;

            // Get sky ribbon bounds relative to the canvas (which starts at 0)
            // skyRect is in screen coordinates, so subtract the wrapper's left position
            const ribbonLeft = skyRect.left - wrapperRect.left;
            const ribbonRight = skyRect.right - wrapperRect.left;
            const ribbonWidth = ribbonRight - ribbonLeft;

            // Pre-calculate curve data for all x positions
            const startX = Math.floor(ribbonLeft), endX = Math.ceil(ribbonRight);
            const curveData = [];
            for (let x = startX; x < endX; x++) {
                const t = (x - ribbonLeft) / ribbonWidth;
                const tempValue = interpolateDataSmooth(weatherData.temperature, t, true);
                const dayValue = interpolateData(weatherData.daylight, t);
                const brightness = getDaylightBrightness(dayValue);
                const color = getTempColor(tempValue);
                const y = curveBottom - (mapTempToDisplayRange(tempValue) * curveHeight * 0.8);
                curveData.push({ x, y, color, brightness, tempValue });
            }

            // Draw filled area under curve (continuous shading for all temps)
            curveData.forEach(d => {
                const gradient = ctx.createLinearGradient(d.x, d.y, d.x, curveBottom);
                for (let i = 0; i <= 8; i++) {
                    const t = i / 8;
                    gradient.addColorStop(t, colorToString(d.color, 0.35 * d.brightness * Math.pow(1 - t, 2.5)));
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(d.x, d.y, 1.5, curveBottom - d.y);
            });

            // Draw curve layers (glow + line + highlight) in single pass per layer
            const layers = [
                { width: 8, alpha: 0.08 },
                { width: 4, alpha: 0.18 },
                { width: 2, alpha: 0.85 },
                { width: 0.8, alpha: 0.5, highlight: true }
            ];
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Draw all curve segments with variable dash pattern based on temperature
            // For temps >= 0°C: continuous line
            // For temps < 0°C: dashed with gaps increasing as temperature decreases
            layers.forEach(layer => {
                // Track dash state across the curve for smooth dashing
                let dashOffset = 0;

                for (let i = 0; i < curveData.length - 1; i++) {
                    const d1 = curveData[i], d2 = curveData[i + 1];
                    const c = layer.highlight
                        ? { r: Math.min(255, d1.color.r + 40), g: Math.min(255, d1.color.g + 40), b: Math.min(255, d1.color.b + 40) }
                        : d1.color;

                    // Apply brightness to both alpha and line width (thinner at night)
                    const widthScale = 0.4 + 0.6 * d1.brightness;
                    ctx.lineWidth = layer.width * widthScale;
                    ctx.strokeStyle = colorToString(c, layer.alpha * d1.brightness);

                    // Get dash pattern based on temperature
                    const dashPattern = getTempDashPattern(d1.tempValue);

                    if (dashPattern) {
                        // Calculate segment length for dash offset tracking
                        const segLength = Math.sqrt(Math.pow(d2.x - d1.x, 2) + Math.pow(d2.y - d1.y, 2));
                        const [dashLen, gapLen] = dashPattern;
                        const cycleLen = dashLen + gapLen;

                        // Determine if we're in a dash or gap based on offset
                        const posInCycle = dashOffset % cycleLen;
                        const inDash = posInCycle < dashLen;

                        if (inDash) {
                            ctx.setLineDash([]);
                            ctx.beginPath();
                            ctx.moveTo(d1.x, d1.y);
                            ctx.lineTo(d2.x, d2.y);
                            ctx.stroke();
                        }
                        // Update dash offset for next segment
                        dashOffset += segLength;
                    } else {
                        // Continuous line for temps >= 0°C
                        ctx.setLineDash([]);
                        ctx.beginPath();
                        ctx.moveTo(d1.x, d1.y);
                        ctx.lineTo(d2.x, d2.y);
                        ctx.stroke();
                        // Reset dash offset when returning to continuous
                        dashOffset = 0;
                    }
                }
            });

            ctx.setLineDash([]); // Reset dash pattern

            // Draw temperature reference line at noon
            // Shows the limited range (tempDisplayMin to tempDisplayMax) using the same color coding
            // Position reference line at noon (center of the ribbon, same vertical range as curve)
            const refLineX = (ribbonLeft + ribbonRight) / 2;
            // Reference line spans full display height (0 to 1 in mapped space)
            // Extended downward with a fade-out region
            const refLineTop = curveBottom - (1.0 * curveHeight * 0.8);  // Top of display range
            const refLineBottom = curveBottom - (0.0 * curveHeight * 0.8);  // Bottom of display range
            const refFadeExtension = 40; // Extra pixels below to fade out
            const refLineEnd = refLineBottom + refFadeExtension;

            // Draw the reference line pixel by pixel with temperature colors (very thin, dimmed)
            // Below 0°C: dashed with gaps increasing as it gets colder (matching temperature curve)
            let refDashOffset = 0;
            let prevDashPattern = null;
            for (let y = refLineTop; y < refLineEnd; y++) {
                // Map y position to temperature (top = hot, bottom = cold)
                const t = (y - refLineTop) / (refLineBottom - refLineTop);
                // Map from display position (0-1) back to actual temperature
                const tempNorm = tempDisplayMax - t * (tempDisplayMax - tempDisplayMin);
                const color = getTempColor(tempNorm);

                const dashPattern = getTempDashPattern(tempNorm);
                // Reset dash offset when transitioning between continuous and dashed
                if ((dashPattern === null) !== (prevDashPattern === null)) {
                    refDashOffset = 0;
                }
                prevDashPattern = dashPattern;

                if (dashPattern) {
                    // Shorter dashes for the reference bar
                    const dashLen = 5;
                    const gapLen = dashPattern[1];
                    const posInCycle = refDashOffset % (dashLen + gapLen);
                    refDashOffset++;
                    if (posInCycle >= dashLen) continue; // In gap, skip this pixel
                }

                // Fade out smoothly in the extension region below the display range
                let alpha = 0.3;
                if (y > refLineBottom) {
                    const fadeT = (y - refLineBottom) / refFadeExtension;
                    alpha *= 0.5 * (1 + Math.cos(fadeT * Math.PI)); // Cosine fade to 0
                }

                ctx.fillStyle = colorToString(color, alpha);
                ctx.fillRect(refLineX, y, 1.5, 1.5);
            }

            // Add tick marks at key temperatures if within display range
            const tickTemps = [0, 10, 20, 40];
            tickTemps.forEach(tempC => {
                const tempNorm = (tempC + 25) / 60;
                if (tempNorm >= tempDisplayMin && tempNorm <= tempDisplayMax) {
                    const tickY = curveBottom - (mapTempToDisplayRange(tempNorm) * curveHeight * 0.8);
                    const tickColor = getTempColor(tempNorm);
                    ctx.fillStyle = colorToString(tickColor, 0.4);
                    const tickWidth = 4;
                    ctx.fillRect(refLineX + 0.75 - tickWidth / 2, tickY, tickWidth, 1);
                }
            });

            // Draw current time marker (only for today's view)
            // Positioned above the sky ribbon
            if (currentDayOffset === 0) {
                const city = cities[currentCity];
                const now = new Date();
                // Get current hour and minute in the city's timezone
                const timeOpts = { hour12: false, hour: '2-digit', minute: '2-digit' };
                if (city.timezone && city.timezone !== 'auto') timeOpts.timeZone = city.timezone;
                const timeStr = now.toLocaleTimeString('en-US', timeOpts);
                const [hours, minutes] = timeStr.split(':').map(Number);
                const currentHour = hours + minutes / 60;

                // Map current time to position within the display range (not full 24h)
                // displayStartHour and displayEndHour define the visible range
                const displayHours = displayEndHour - displayStartHour;
                const currentTimeT = (currentHour - displayStartHour) / displayHours;

                // Only draw marker if current time is within the displayed range
                if (currentTimeT >= 0 && currentTimeT <= 1) {
                    // Calculate X position within the ribbon bounds
                    const markerX = ribbonLeft + currentTimeT * ribbonWidth;

                    // Get the actual position of the sky ribbon element relative to wrapper
                    const skyTopInWrapper = (skyRect.top - wrapperRect.top) - 2;

                    // Draw a refined triangle marker with soft glow
                    // Outer glow
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.beginPath();
                    ctx.moveTo(markerX, skyTopInWrapper + 1);
                    ctx.lineTo(markerX - 7, skyTopInWrapper - 10);
                    ctx.lineTo(markerX + 7, skyTopInWrapper - 10);
                    ctx.closePath();
                    ctx.fill();

                    // Inner triangle
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(markerX, skyTopInWrapper);
                    ctx.lineTo(markerX - 4, skyTopInWrapper - 7);
                    ctx.lineTo(markerX + 4, skyTopInWrapper - 7);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Wind animation state
        let windAnimationId = null;
        let windStreaks = [];
        const WIND_THRESHOLD = 0.2; // Only show wind when > 20% of max (16+ km/h)

        // Check if there's substantial wind to animate
        function hasSubstantialWind() {
            if (!weatherData.windSpeed) return false;
            return weatherData.windSpeed.some(w => w >= WIND_THRESHOLD);
        }

        // Get wind display boundaries in screen coordinates
        function getWindBounds() {
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const skyRibbonEl = document.getElementById('skyRibbon');
            const wrapperRect = wrapper.getBoundingClientRect();
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const height = wrapperRect.height || window.innerHeight * 0.6;

            // Calculate sky ribbon position relative to wrapper
            const skyBottomInWrapper = (skyRect.bottom - wrapperRect.top);

            // Match the temperature curve positioning (shifted up 200px)
            const curveHeight = Math.min(height * 0.396, 216);
            const curveBottom = skyBottomInWrapper + curveHeight * 0.8 - 160;
            const curveTop = curveBottom - curveHeight;

            // Wind display area spans the full temperature curve height
            // Use the same mapping as the temperature curve
            const windTopY = curveBottom - (1.0 * curveHeight * 0.8);  // Top of curve
            const windBottomY = curveBottom - (0.0 * curveHeight * 0.8);  // Bottom of curve

            // Get sky ribbon bounds relative to the canvas (which starts at 0)
            const ribbonLeft = skyRect.left - wrapperRect.left;
            const ribbonRight = skyRect.right - wrapperRect.left;

            return {
                left: ribbonLeft,
                right: ribbonRight,
                top: windTopY,
                bottom: windBottomY,
                width: ribbonRight - ribbonLeft,
                height: windBottomY - windTopY
            };
        }

        // Initialize wind streaks based on weather data
        // Streaks are positioned at fixed X locations (corresponding to hours)
        function initWindStreaks() {
            windStreaks = [];
            if (!hasSubstantialWind()) return;

            const bounds = getWindBounds();

            // Create streaks at fixed horizontal positions across the ribbon
            // Multiple streaks per column for density
            const columnsCount = 40; // Number of x positions (halved for less density)
            const streaksPerColumn = 2; // Reduced from 3

            for (let col = 0; col < columnsCount; col++) {
                const xPos = (col / columnsCount) * bounds.width;
                for (let s = 0; s < streaksPerColumn; s++) {
                    windStreaks.push({
                        x: xPos,
                        y: Math.random() * bounds.height,
                        baseY: Math.random() * bounds.height, // Fixed base Y position
                        length: 30 + Math.random() * 50,
                        phase: Math.random() * Math.PI * 2, // Animation phase offset
                        speed: 0.5 + Math.random() * 1.5, // Animation speed
                        opacity: 0.25 + Math.random() * 0.35,
                        seed: Math.random() * 1000
                    });
                }
            }
        }


        // Draw animated wind streaks
        function drawWindAnimation(timestamp) {
            const canvas = document.getElementById('windCanvas');
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const ctx = canvas.getContext('2d');

            // Get wrapper dimensions for relative positioning
            const wrapperRect = wrapper.getBoundingClientRect();
            const width = window.innerWidth;
            const height = wrapperRect.height || window.innerHeight * 0.6;

            // Set canvas to wrapper size with retina support
            canvas.width = width * 2;
            canvas.height = height * 2;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(2, 2);

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (!hasSubstantialWind() || windStreaks.length === 0) {
                windAnimationId = requestAnimationFrame(drawWindAnimation);
                return;
            }

            const bounds = getWindBounds();
            const time = timestamp / 1000;

            // Temperature curve parameters (same as in drawTemperatureCurve)
            // Get sky ribbon position for proper curve placement
            const skyRibbonEl = document.getElementById('skyRibbon');
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const skyBottomInWrapper = (skyRect.bottom - wrapperRect.top);
            const curveHeight = Math.min(height * 0.396, 216);
            const curveBottom = skyBottomInWrapper + curveHeight * 0.8 - 160;
            const curveTop = curveBottom - curveHeight;

            // Horizontal orientation
            const angle = 0;

            // Small vertical offset above the temperature curve (negative = above)
            const verticalOffset = -5;

            // Draw each wind streak
            windStreaks.forEach(streak => {
                // Get wind data at streak's fixed x position (normalized 0-1 across ribbon width)
                const t = streak.x / bounds.width;
                const tClamped = Math.max(0, Math.min(1, t));
                const windSpeed = interpolateData(weatherData.windSpeed, tClamped);
                const dayValue = interpolateData(weatherData.daylight, tClamped);
                const tempValue = interpolateData(weatherData.temperature, tClamped);

                // Only draw if wind is substantial at this position
                if (windSpeed < WIND_THRESHOLD) return;

                // Calculate streak properties based on wind
                const windIntensity = (windSpeed - WIND_THRESHOLD) / (1 - WIND_THRESHOLD);
                const streakLength = streak.length * (0.5 + windIntensity);

                // Animated shimmer effect - opacity pulses over time
                const shimmer = 0.5 + 0.5 * Math.sin(time * streak.speed + streak.phase);

                // Calculate screen coordinates
                // X is fixed at the streak's horizontal position
                const screenX = bounds.left + streak.x;
                // Y is at the temperature curve position - offset (above) - streak's baseY offset
                const tempY = curveBottom - (mapTempToDisplayRange(tempValue) * curveHeight * 0.8);
                const screenY = tempY + verticalOffset - streak.baseY * 0.3; // baseY provides variation above
                const endX = screenX + streakLength;
                const endY = screenY + angle * streakLength;

                // Calculate streak color - white for visibility
                const brightness = 255;
                // Fade based on distance from temperature curve
                const distFromCurve = streak.baseY * 0.3;
                const distanceFade = Math.max(0, 1 - distFromCurve / 30);
                const alpha = streak.opacity * windIntensity * (0.7 + dayValue * 0.3) * 4.5 * distanceFade * shimmer;

                // Skip if too faint
                if (alpha < 0.02) return;

                // Draw the wind streak as a tapered line
                const gradient = ctx.createLinearGradient(screenX, screenY, endX, endY);
                gradient.addColorStop(0, `rgba(${brightness}, ${brightness}, ${brightness + 10}, 0)`);
                gradient.addColorStop(0.15, `rgba(${brightness}, ${brightness}, ${brightness + 10}, ${alpha})`);
                gradient.addColorStop(0.7, `rgba(${brightness}, ${brightness}, ${brightness + 10}, ${alpha * 0.7})`);
                gradient.addColorStop(1, `rgba(${brightness}, ${brightness}, ${brightness + 10}, 0)`);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 1 + windIntensity;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(screenX, screenY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            });

            windAnimationId = requestAnimationFrame(drawWindAnimation);
        }

        // Start wind animation
        function startWindAnimation() {
            if (windAnimationId) {
                cancelAnimationFrame(windAnimationId);
            }
            initWindStreaks();
            windAnimationId = requestAnimationFrame(drawWindAnimation);
        }

        // Stop wind animation
        function stopWindAnimation() {
            if (windAnimationId) {
                cancelAnimationFrame(windAnimationId);
                windAnimationId = null;
            }
            // Clear wind canvas
            const canvas = document.getElementById('windCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // ===== Year Temperature Band =====

        // Fetch year band data: 3 API calls merged into a 365/366 entry array
        async function fetchYearBandData(cityKey) {
            if (yearBandCache[cityKey]) return yearBandCache[cityKey];

            const city = cities[cityKey];
            if (!city) return null;

            const now = new Date();
            const tz = city.timezone && city.timezone !== 'auto' ? city.timezone : 'UTC';
            const cityDateStr = now.toLocaleDateString('en-CA', { timeZone: tz });
            const cityToday = new Date(cityDateStr + 'T00:00:00');
            const year = cityToday.getFullYear();
            const isLeapYear = (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
            const daysInYear = isLeapYear ? 366 : 365;

            const jan1 = `${year}-01-01`;
            const dec31 = `${year}-12-31`;

            // Yesterday's date
            const yesterday = new Date(cityToday);
            yesterday.setDate(yesterday.getDate() - 1);
            const yesterdayStr = yesterday.toISOString().split('T')[0];

            // Today string
            const todayStr = cityDateStr;

            // Forecast end (today + 14)
            const forecastEnd = new Date(cityToday);
            forecastEnd.setDate(forecastEnd.getDate() + 14);
            const forecastEndStr = forecastEnd.toISOString().split('T')[0];

            // Fill start = day after forecast end
            const fillStart = new Date(forecastEnd);
            fillStart.setDate(fillStart.getDate() + 1);
            const fillStartStr = fillStart.toISOString().split('T')[0];

            // Last year equivalent dates for fill
            const lastYear = year - 1;
            const fillStartLastYear = fillStartStr.replace(`${year}`, `${lastYear}`);
            const dec31LastYear = `${lastYear}-12-31`;

            // Build result array
            const result = new Array(daysInYear);

            try {
                // Build the 3 API calls
                const calls = [];

                // 1. Archive: Jan 1 this year → yesterday (past real data)
                if (yesterdayStr >= jan1) {
                    calls.push(
                        fetch(`https://archive-api.open-meteo.com/v1/archive?latitude=${city.lat}&longitude=${city.lon}&hourly=temperature_2m&timezone=${encodeURIComponent(tz)}&start_date=${jan1}&end_date=${yesterdayStr}`)
                            .then(r => r.json())
                            .then(data => ({ type: 'past', data }))
                            .catch(() => ({ type: 'past', data: null }))
                    );
                }

                // 2. Forecast: today → today + 14 days
                calls.push(
                    fetch(`https://api.open-meteo.com/v1/forecast?latitude=${city.lat}&longitude=${city.lon}&hourly=temperature_2m&timezone=${encodeURIComponent(tz)}&start_date=${todayStr}&end_date=${forecastEndStr}`)
                        .then(r => r.json())
                        .then(data => ({ type: 'forecast', data }))
                        .catch(() => ({ type: 'forecast', data: null }))
                );

                // 3. Archive last year: fill remaining days
                if (fillStartStr <= dec31) {
                    calls.push(
                        fetch(`https://archive-api.open-meteo.com/v1/archive?latitude=${city.lat}&longitude=${city.lon}&hourly=temperature_2m&timezone=${encodeURIComponent(tz)}&start_date=${fillStartLastYear}&end_date=${dec31LastYear}`)
                            .then(r => r.json())
                            .then(data => ({ type: 'fill', data }))
                            .catch(() => ({ type: 'fill', data: null }))
                    );
                }

                const results = await Promise.all(calls);

                // Helper: day index from date string (0 = Jan 1)
                function dayIndex(dateStr) {
                    const d = new Date(dateStr + 'T00:00:00');
                    const j1 = new Date(`${year}-01-01T00:00:00`);
                    return Math.round((d - j1) / 86400000);
                }

                // Astronomical daylight fraction from latitude + day of year
                // Smooth sinusoidal; handles polar night (0) and midnight sun (1)
                const latRad = city.lat * Math.PI / 180;
                function astroDay(doy) {
                    const decl = -23.44 * Math.cos(2 * Math.PI / 365 * (doy + 10)) * Math.PI / 180;
                    const cosHA = -Math.tan(latRad) * Math.tan(decl);
                    if (cosHA <= -1) return 1.0; // midnight sun
                    if (cosHA >= 1) return 0.0;  // polar night
                    return Math.acos(cosHA) / Math.PI;
                }

                // Process results: group hourly data by day, average hours 9–15 (noon ± 3h)
                for (const res of results) {
                    if (!res.data || !res.data.hourly || !res.data.hourly.time) continue;
                    const times = res.data.hourly.time;
                    const temps = res.data.hourly.temperature_2m;

                    // Group by day: collect temps for hours 9–15
                    const dayTemps = {};
                    for (let i = 0; i < times.length; i++) {
                        if (temps[i] == null) continue;
                        const dtStr = times[i]; // e.g. "2026-02-24T09:00"
                        const dateStr = dtStr.substring(0, 10);
                        const hour = parseInt(dtStr.substring(11, 13), 10);
                        if (hour >= 9 && hour <= 15) {
                            if (!dayTemps[dateStr]) dayTemps[dateStr] = [];
                            dayTemps[dateStr].push(temps[i]);
                        }
                    }

                    // Compute mean and assign to result
                    for (const [dateStr, values] of Object.entries(dayTemps)) {
                        const meanTemp = values.reduce((a, b) => a + b, 0) / values.length;
                        let idx;

                        if (res.type === 'fill') {
                            const thisYearDate = dateStr.replace(`${lastYear}`, `${year}`);
                            idx = dayIndex(thisYearDate);
                        } else {
                            idx = dayIndex(dateStr);
                        }

                        if (idx >= 0 && idx < daysInYear) {
                            result[idx] = {
                                date: dateStr,
                                tempC: Math.round(meanTemp * 10) / 10,
                                tier: res.type === 'past' ? 1 : res.type === 'forecast' ? 2 : 3,
                                daylightFrac: astroDay(idx)
                            };
                        }
                    }
                }

                // Fill any gaps with null
                for (let i = 0; i < daysInYear; i++) {
                    if (!result[i]) {
                        const d = new Date(`${year}-01-01T00:00:00`);
                        d.setDate(d.getDate() + i);
                        result[i] = { date: d.toISOString().split('T')[0], tempC: null, tier: 0, daylightFrac: astroDay(i) };
                    }
                }

                yearBandCache[cityKey] = result;
                return result;

            } catch (err) {
                console.error('Year band fetch failed:', err);
                return null;
            }
        }

        // Draw the year band on canvas
        function drawYearBand() {
            const container = document.getElementById('yearBandContainer');
            const canvas = document.getElementById('yearBandCanvas');
            if (!canvas || !container) return;

            const data = yearBandCache[currentCity];
            if (!data) {
                container.classList.remove('visible');
                return;
            }

            const rect = container.getBoundingClientRect();
            const w = rect.width;
            const totalH = rect.height;
            if (w <= 0 || totalH <= 0) return;

            // Band on top, upward-pointing triangle below
            const triH = 6;
            const triGap = 1;
            const bandTop = 0;
            const bandH = totalH - triH - triGap;
            const bandR = bandH / 2;

            // Retina support
            const dpr = window.devicePixelRatio || 1;
            canvas.width = w * dpr;
            canvas.height = totalH * dpr;
            canvas.style.width = w + 'px';
            canvas.style.height = totalH + 'px';

            const ctx = canvas.getContext('2d');
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            const daysInYear = data.length;

            // Compute today index (needed for triangle + markers)
            const city = cities[currentCity];
            const tz = city && city.timezone && city.timezone !== 'auto' ? city.timezone : 'UTC';
            const now = new Date();
            const cityDateStr = now.toLocaleDateString('en-CA', { timeZone: tz });
            const cityToday = new Date(cityDateStr + 'T00:00:00');
            const jan1 = new Date(`${cityToday.getFullYear()}-01-01T00:00:00`);
            const todayIndex = Math.round((cityToday - jan1) / 86400000);

            // Clip to pill shape for the band area
            ctx.save();
            ctx.beginPath();
            // Manual roundRect for Safari 12 compatibility
            var rr_x = 0, rr_y = bandTop, rr_w = w, rr_h = bandH, rr_r = bandR;
            ctx.moveTo(rr_x + rr_r, rr_y);
            ctx.lineTo(rr_x + rr_w - rr_r, rr_y);
            ctx.arcTo(rr_x + rr_w, rr_y, rr_x + rr_w, rr_y + rr_r, rr_r);
            ctx.lineTo(rr_x + rr_w, rr_y + rr_h - rr_r);
            ctx.arcTo(rr_x + rr_w, rr_y + rr_h, rr_x + rr_w - rr_r, rr_y + rr_h, rr_r);
            ctx.lineTo(rr_x + rr_r, rr_y + rr_h);
            ctx.arcTo(rr_x, rr_y + rr_h, rr_x, rr_y + rr_h - rr_r, rr_r);
            ctx.lineTo(rr_x, rr_y + rr_r);
            ctx.arcTo(rr_x, rr_y, rr_x + rr_r, rr_y, rr_r);
            ctx.clip();

            // Draw each day as a vertical color slice with daylight-aware fade
            // Each slice fades from center (noon) outward; bright portion = daylight duration
            for (let i = 0; i < daysInYear; i++) {
                const x = (i / daysInYear) * w;
                const sliceW = Math.ceil(w / daysInYear) + 1;

                const entry = data[i];
                if (!entry || entry.tempC == null) {
                    continue;
                }

                const normTemp = (entry.tempC + 25) / 60;
                const color = getTempColor(normTemp);
                const baseAlpha = 0.35;
                const rawDlf = entry.daylightFrac || 0.5;
                // Amplify deviation from 0.5 to enhance visual difference
                const dlf = Math.max(0.08, Math.min(0.95, 0.5 + (rawDlf - 0.5) * 2.5));

                // Trapezoid gradient: transparent edges, bright center sized by daylight
                const grad = ctx.createLinearGradient(x, bandTop, x, bandTop + bandH);
                const sunriseStop = Math.max(0.01, 0.5 - dlf / 2);
                const sunsetStop = Math.min(0.99, 0.5 + dlf / 2);
                grad.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
                grad.addColorStop(sunriseStop, `rgba(${color.r}, ${color.g}, ${color.b}, ${baseAlpha})`);
                grad.addColorStop(sunsetStop, `rgba(${color.r}, ${color.g}, ${color.b}, ${baseAlpha})`);
                grad.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);

                ctx.fillStyle = grad;
                ctx.fillRect(x, bandTop, sliceW, bandH);
            }



            // Viewed day marker (if navigating away from today)
            if (currentDayOffset !== 0) {
                const viewedIndex = todayIndex + currentDayOffset;
                if (viewedIndex >= 0 && viewedIndex < daysInYear) {
                    const viewedX = (viewedIndex / daysInYear) * w;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.moveTo(viewedX, bandTop);
                    ctx.lineTo(viewedX, bandTop + bandH);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            ctx.restore(); // Remove pill clip

            // Upward-pointing triangle below the band for today
            if (todayIndex >= 0 && todayIndex < daysInYear) {
                const todayX = (todayIndex / daysInYear) * w;
                const triW = 4; // half-width
                const triTop = bandH + triGap; // just below the band
                ctx.fillStyle = 'rgba(160, 170, 185, 0.45)';
                ctx.beginPath();
                ctx.moveTo(todayX, triTop);                   // top point (pointing up)
                ctx.lineTo(todayX - triW, triTop + triH);    // bottom-left
                ctx.lineTo(todayX + triW, triTop + triH);    // bottom-right
                ctx.closePath();
                ctx.fill();
            }

            // On touch devices, always show; on desktop, show when map is active or mousemove controls visibility
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0 || isWorldMapActive()) {
                container.classList.add('visible');
            }
        }

        // Year band: click to navigate to that day
        function initYearBandInteraction() {
            const container = document.getElementById('yearBandContainer');
            const canvas = document.getElementById('yearBandCanvas');
            const tooltip = document.getElementById('yearBandTooltip');
            if (!canvas || !container || !tooltip) return;

            canvas.addEventListener('click', async (e) => {
                const data = yearBandCache[currentCity];
                if (!data) return;

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const dayIdx = Math.floor((x / rect.width) * data.length);

                if (dayIdx < 0 || dayIdx >= data.length) return;
                const entry = data[dayIdx];
                if (!entry || entry.tempC == null) return;

                // Compute offset from today
                const city = cities[currentCity];
                const tz = city && city.timezone && city.timezone !== 'auto' ? city.timezone : 'UTC';
                const now = new Date();
                const cityDateStr = now.toLocaleDateString('en-CA', { timeZone: tz });
                const cityToday = new Date(cityDateStr + 'T00:00:00');
                const jan1 = new Date(`${cityToday.getFullYear()}-01-01T00:00:00`);
                const todayIndex = Math.round((cityToday - jan1) / 86400000);
                let offset = dayIdx - todayIndex;

                // Tier 3 (last year fill): navigate to the equivalent date last year
                if (entry.tier === 3) {
                    const lastYearDate = new Date(entry.date + 'T00:00:00');
                    offset = Math.round((lastYearDate - cityToday) / 86400000);
                }

                // Block clicks beyond forecast range for tier 2 future days
                if (entry.tier === 2 && offset > maxFutureOffset) return;

                currentDayOffset = offset;
                await refreshView();

                // Prefetch past days if needed
                if (currentDayOffset <= prefetchedPastBoundary + 3) {
                    prefetchPastDays(currentCity, prefetchedPastBoundary);
                }
            });

            // Hover tooltip (desktop only)
            if (!('ontouchstart' in window) && navigator.maxTouchPoints <= 0) {
                canvas.addEventListener('mousemove', (e) => {
                    const data = yearBandCache[currentCity];
                    if (!data) return;

                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const dayIdx = Math.floor((x / rect.width) * data.length);

                    if (dayIdx < 0 || dayIdx >= data.length || !data[dayIdx] || data[dayIdx].tempC == null) {
                        tooltip.style.display = 'none';
                        return;
                    }

                    const entry = data[dayIdx];
                    const normTemp = (entry.tempC + 25) / 60;
                    const color = getTempColor(normTemp);

                    // Format date as "Mon Day" (e.g., "Feb 24")
                    const year = new Date().getFullYear();
                    const jan1 = new Date(`${year}-01-01T00:00:00`);
                    const date = new Date(jan1);
                    date.setDate(date.getDate() + dayIdx);
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const dateStr = `${monthNames[date.getMonth()]} ${date.getDate()}`;

                    // Daylight duration from daylightFrac (fraction of 24h), rounded to 5 min
                    // const daylightTotalMin = Math.round((entry.daylightFrac * 24 * 60) / 5) * 5;
                    // const dlH = Math.floor(daylightTotalMin / 60);
                    // const dlM = daylightTotalMin % 60;
                    // const daylightStr = `${dlH}h${String(dlM).padStart(2, '0')}`;

                    const tierLabel = entry.tier === 3 ? ' <span style="color:rgba(200,210,230,0.5)">(last year)</span>' : '';
                    tooltip.innerHTML = `${dateStr} · <span style="color:rgb(${color.r},${color.g},${color.b})">${Math.round(entry.tempC)}°C</span>${tierLabel}`;
                    tooltip.style.left = `${e.clientX}px`;
                    tooltip.style.top = `${rect.top}px`;
                    tooltip.style.display = 'block';
                });

                canvas.addEventListener('mouseleave', () => {
                    tooltip.style.display = 'none';
                });
            }
        }

        // Year band auto-show/hide on mouse proximity (desktop only)
        let yearBandFadeTimeout = null;
        let yearBandCleanupTimeout = null;

        function isWorldMapActive() {
            const mc = document.getElementById('worldMapCanvas');
            return mc && (mc.classList.contains('visible') || mc.style.pointerEvents === 'auto');
        }

        function showYearBand() {
            const container = document.getElementById('yearBandContainer');
            if (!container) return;
            if (yearBandFadeTimeout) { clearTimeout(yearBandFadeTimeout); yearBandFadeTimeout = null; }
            if (yearBandCleanupTimeout) { clearTimeout(yearBandCleanupTimeout); yearBandCleanupTimeout = null; }
            container.style.pointerEvents = '';
            if (!container.classList.contains('visible')) {
                container.classList.add('visible');
            }
        }

        function scheduleYearBandFadeOut() {
            if (yearBandFadeTimeout || yearBandCleanupTimeout) return;
            if (isWorldMapActive()) return;
            const container = document.getElementById('yearBandContainer');
            if (!container.classList.contains('visible')) return;
            yearBandFadeTimeout = setTimeout(() => {
                yearBandFadeTimeout = null;
                container.style.pointerEvents = 'auto';
                container.classList.remove('visible');
                yearBandCleanupTimeout = setTimeout(() => {
                    yearBandCleanupTimeout = null;
                    container.style.pointerEvents = '';
                }, 5500);
            }, 10000);
        }

        function initYearBandHover() {
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) return;
            document.addEventListener('mousemove', (e) => {
                const container = document.getElementById('yearBandContainer');
                if (!container) return;
                const rect = container.getBoundingClientRect();
                // Show when hovering over the band area (with 20px above for easier targeting) or when map is active
                const hoverZoneTop = rect.top - 20;
                if (((e.clientY >= hoverZoneTop && e.clientY <= rect.bottom) || isWorldMapActive()) && yearBandCache[currentCity]) {
                    showYearBand();
                } else if (container.classList.contains('visible') || container.style.pointerEvents === 'auto') {
                    if (!yearBandFadeTimeout && !yearBandCleanupTimeout) {
                        scheduleYearBandFadeOut();
                    }
                }
            });
            document.addEventListener('mouseleave', () => {
                const container = document.getElementById('yearBandContainer');
                if (container && (container.classList.contains('visible') || container.style.pointerEvents === 'auto')) {
                    if (!yearBandFadeTimeout && !yearBandCleanupTimeout) {
                        scheduleYearBandFadeOut();
                    }
                }
            });
        }

        // Initialize all visualizations (static, no animation)
        function draw() {
            // Draw sky ribbon first so its dimensions are available for temperature curve positioning
            drawSkyRibbon();
            // Force layout reflow so getBoundingClientRect returns updated dimensions
            document.getElementById('skyRibbon').getBoundingClientRect();
            drawTemperatureCurve();
            drawYearBand();
            startWindAnimation();
        }

        // Handle resize with debounce
        let resizeTimer = null;
        window.addEventListener('resize', () => {
            if (resizeTimer) clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                resizeTimer = null;
                draw();
                resizeWorldMap();
            }, 200);
        });

        // Fetch city suggestions from geocoding API
        async function fetchCitySuggestions(query) {
            if (query.length < 2) return [];
            const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5&language=en&format=json`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    return data.results.map(result => ({
                        name: result.name,
                        lat: result.latitude,
                        lon: result.longitude,
                        timezone: result.timezone,
                        country: result.country,
                        admin1: result.admin1 || ''
                    }));
                }
                return [];
            } catch (error) {
                console.error('Geocoding failed:', error);
                return [];
            }
        }

        // City label click handling
        let isEditingCity = false;
        let debounceTimer = null;
        let selectedSuggestion = null;

        function startCityEdit(e) {
            if (isEditingCity) return;
            isEditingCity = true;
            selectedSuggestion = null;

            // Get the current city label element (may have been recreated)
            const currentCityLabel = e ? e.currentTarget : document.getElementById('cityLabel');
            const currentName = currentCityLabel.textContent;

            // Create wrapper for input and suggestions
            const wrapper = document.createElement('div');
            wrapper.className = 'city-input-wrapper';

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'city-input';
            input.value = '';
            input.placeholder = currentName;

            wrapper.appendChild(input);
            currentCityLabel.replaceWith(wrapper);
            input.focus();

            // Create suggestions container
            const suggestionsContainer = document.createElement('div');
            suggestionsContainer.className = 'city-suggestions';
            suggestionsContainer.style.display = 'none';
            wrapper.appendChild(suggestionsContainer);

            function showSuggestions(suggestions) {
                suggestionsContainer.innerHTML = '';
                if (suggestions.length === 0) {
                    suggestionsContainer.style.display = 'none';
                    return;
                }

                suggestions.forEach(suggestion => {
                    const div = document.createElement('div');
                    div.className = 'city-suggestion';

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'city-suggestion-name';
                    nameSpan.textContent = suggestion.name;

                    const detailSpan = document.createElement('span');
                    detailSpan.className = 'city-suggestion-detail';
                    detailSpan.textContent = suggestion.admin1
                        ? `${suggestion.admin1}, ${suggestion.country}`
                        : suggestion.country;

                    div.appendChild(nameSpan);
                    div.appendChild(detailSpan);

                    div.addEventListener('mousedown', (e) => {
                        e.preventDefault(); // Prevent blur
                        selectCity(suggestion);
                    });

                    suggestionsContainer.appendChild(div);
                });

                suggestionsContainer.style.display = 'block';
            }

            async function selectCity(suggestion) {
                selectedSuggestion = suggestion;

                // Create a new city entry
                const cityKey = suggestion.name.toLowerCase().replace(/\s+/g, '-') + '-' + Date.now();
                cities[cityKey] = {
                    name: suggestion.name,
                    lat: suggestion.lat,
                    lon: suggestion.lon,
                    timezone: suggestion.timezone
                };
                currentCity = cityKey;
                currentDayOffset = 0; // Reset to today's view when changing location

                // Restore label first
                restoreLabel(suggestion.name, false);
                await refreshView();
                // Show "set as default" option after refresh completes
                showSetDefaultButton();
                // Prefetch remaining days for new city
                prefetchRemainingDays(cityKey);
                // Show world map with animated dot transition
                showWorldMap(suggestion.lat, suggestion.lon);
            }

            function restoreLabel(name) {
                isEditingCity = false;
                if (debounceTimer) clearTimeout(debounceTimer);

                const newLabel = document.createElement('span');
                newLabel.className = 'city-label';
                newLabel.id = 'cityLabel';
                newLabel.textContent = name;
                wrapper.replaceWith(newLabel);
                newLabel.addEventListener('click', startCityEdit);
            }

            async function finishEdit() {
                if (selectedSuggestion) return; // Already handled by selectCity

                const newCityName = input.value.trim();

                if (newCityName) {
                    // Fetch suggestions and pick the first one
                    const suggestions = await fetchCitySuggestions(newCityName);
                    if (suggestions.length > 0) {
                        await selectCity(suggestions[0]);
                        return;
                    }
                }

                // No valid input or city not found, restore original
                restoreLabel(currentName);
            }

            // Debounced input handler for suggestions
            input.addEventListener('input', () => {
                if (debounceTimer) clearTimeout(debounceTimer);

                const query = input.value.trim();
                if (query.length < 2) {
                    suggestionsContainer.style.display = 'none';
                    return;
                }

                debounceTimer = setTimeout(async () => {
                    const suggestions = await fetchCitySuggestions(query);
                    showSuggestions(suggestions);
                }, 300);
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    suggestionsContainer.style.display = 'none';
                    finishEdit();
                } else if (e.key === 'Escape') {
                    if (debounceTimer) clearTimeout(debounceTimer);
                    restoreLabel(currentName);
                }
            });

            input.addEventListener('blur', () => {
                // Small delay to allow click on suggestion
                setTimeout(() => {
                    if (isEditingCity && !selectedSuggestion) {
                        finishEdit();
                    }
                }, 200);
            });
        }

        document.getElementById('cityLabel').addEventListener('click', startCityEdit);

        // Update city label when view refreshes
        function updateCityLabel() {
            const label = document.getElementById('cityLabel');
            if (label && cities[currentCity]) {
                label.textContent = cities[currentCity].name;
            }
        }

        // Show "set as default" button below city label
        function showSetDefaultButton() {
            // Remove any existing set-default button
            const existing = document.querySelector('.set-default-btn');
            if (existing) existing.remove();

            const cityLabel = document.getElementById('cityLabel');
            const setDefaultBtn = document.createElement('span');
            setDefaultBtn.className = 'set-default-btn';
            setDefaultBtn.textContent = 'set as default';
            setDefaultBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                saveDefaultCity(currentCity);
                setDefaultBtn.textContent = 'saved!';
                setTimeout(() => setDefaultBtn.remove(), 1500);
            });
            cityLabel.appendChild(setDefaultBtn);

            // Auto-hide after 8 seconds if not clicked
            setTimeout(() => {
                if (setDefaultBtn.parentNode) setDefaultBtn.remove();
            }, 8000);
        }

        // Show "no forecast beyond this day" below right arrow
        function showForecastLimitMessage() {
            const existing = document.querySelector('.forecast-limit-msg');
            if (existing) existing.remove();

            const dateNav = document.querySelector('.date-nav');
            const msg = document.createElement('span');
            msg.className = 'forecast-limit-msg';
            msg.textContent = 'no forecast beyond this day';
            dateNav.appendChild(msg);

            setTimeout(() => {
                if (msg.parentNode) msg.remove();
            }, 5000);
        }

        // Handle day navigation
        document.getElementById('prevDay').addEventListener('click', async () => {
            currentDayOffset--;
            await refreshView();
            // Prefetch more past days if approaching the boundary
            if (currentDayOffset <= prefetchedPastBoundary + 3) {
                prefetchPastDays(currentCity, prefetchedPastBoundary);
            }
        });

        document.getElementById('nextDay').addEventListener('click', async () => {
            if (currentDayOffset < maxFutureOffset) {
                currentDayOffset++;
                await refreshView();
                if (currentDayOffset >= maxFutureOffset) {
                    showForecastLimitMessage();
                }
            } else {
                showForecastLimitMessage();
            }
        });

        // Click on day label to go to today
        document.getElementById('dayLabel').addEventListener('click', async () => {
            if (currentDayOffset !== 0) {
                currentDayOffset = 0;
                await refreshView();
            }
        });

        // Handle random capital button
        document.getElementById('randomBtn').addEventListener('click', async () => {
            currentExtraDots = null; // Clear similar-city dots
            // Pick a random capital different from current
            let randomCapital;
            do {
                randomCapital = worldCapitals[Math.floor(Math.random() * worldCapitals.length)];
            } while (cities[currentCity] && randomCapital.name === cities[currentCity].name);

            // Create a new city entry
            const cityKey = randomCapital.name.toLowerCase().replace(/\s+/g, '-') + '-' + Date.now();
            cities[cityKey] = {
                name: randomCapital.name,
                lat: randomCapital.lat,
                lon: randomCapital.lon,
                timezone: randomCapital.timezone
            };
            currentCity = cityKey;
            currentDayOffset = 0; // Reset to today's view

            // Skip temp range recalculation to keep the temperature bar unchanged
            await refreshView(true);
            prefetchRemainingDays(cityKey);

            // Show world map overlay with the chosen city
            showWorldMap(randomCapital.lat, randomCapital.lon);
        });

        /* // Handle similar capitals button — commented out for now
        const similarCache = {};
        document.getElementById('similarBtn').addEventListener('click', async () => {
            const btn = document.getElementById('similarBtn');
            if (!fullWeatherData || !fullWeatherData.temperature || !fullWeatherData.daylight) return;

            // Compute current city's mean daytime temperature in °C
            let sum = 0, count = 0;
            for (let i = 0; i < 24; i++) {
                if (fullWeatherData.daylight[i] > 0.5) {
                    sum += fullWeatherData.temperature[i];
                    count++;
                }
            }
            if (count === 0) return;
            const currentMeanNorm = sum / count;
            const currentMeanC = currentMeanNorm * 60 - 25;

            // Get date string for the selected day
            const city = cities[currentCity];
            const dateStr = getDateForOffset(city, currentDayOffset);
            const cacheKey = dateStr;

            btn.textContent = '...';
            btn.disabled = true;

            try {
                let allCapitalTemps;
                if (similarCache[cacheKey]) {
                    allCapitalTemps = similarCache[cacheKey];
                } else {
                    allCapitalTemps = await fetchCityTemperatures(dateStr);
                    similarCache[cacheKey] = allCapitalTemps;
                }

                // Filter capitals within ±4°C of current city's mean daytime temp
                const threshold = 4;
                const currentLat = city.lat;
                const currentLon = city.lon;
                const similarDots = [];
                allCapitalTemps.forEach(cap => {
                    // Skip current city (within ~0.1° lat/lon)
                    if (Math.abs(cap.lat - currentLat) < 0.2 && Math.abs(cap.lon - currentLon) < 0.2) return;
                    if (cap.meanTempC != null && Math.abs(cap.meanTempC - currentMeanC) <= threshold) {
                        const normTemp = (cap.meanTempC + 25) / 60;
                        similarDots.push({
                            lat: cap.lat,
                            lon: cap.lon,
                            color: getTempColor(normTemp)
                        });
                    }
                });

                currentExtraDots = similarDots;
                showWorldMap(city.lat, city.lon);
            } catch (e) {
                console.error('Failed to fetch similar capitals:', e);
            } finally {
                btn.textContent = 'similar';
                btn.disabled = false;
            }
        });

        // Cities with 1M+ population for temperature comparison
        const majorCities = [
            // East Asia — China
            { name: 'Shanghai', lat: 31.23, lon: 121.47 },
            { name: 'Beijing', lat: 39.90, lon: 116.41 },
            { name: 'Guangzhou', lat: 23.13, lon: 113.26 },
            { name: 'Shenzhen', lat: 22.54, lon: 114.06 },
            { name: 'Chengdu', lat: 30.57, lon: 104.07 },
            { name: 'Chongqing', lat: 29.56, lon: 106.55 },
            { name: 'Tianjin', lat: 39.14, lon: 117.18 },
            { name: 'Wuhan', lat: 30.59, lon: 114.31 },
            { name: 'Hangzhou', lat: 30.27, lon: 120.15 },
            { name: 'Nanjing', lat: 32.06, lon: 118.80 },
            { name: "Xi'an", lat: 34.26, lon: 108.94 },
            { name: 'Zhengzhou', lat: 34.75, lon: 113.65 },
            { name: 'Shenyang', lat: 41.80, lon: 123.43 },
            { name: 'Changsha', lat: 28.23, lon: 112.94 },
            { name: 'Dongguan', lat: 23.04, lon: 113.72 },
            { name: 'Harbin', lat: 45.75, lon: 126.65 },
            { name: 'Kunming', lat: 25.04, lon: 102.68 },
            { name: 'Jinan', lat: 36.67, lon: 116.98 },
            { name: 'Dalian', lat: 38.91, lon: 121.60 },
            { name: 'Qingdao', lat: 36.07, lon: 120.38 },
            { name: 'Fuzhou', lat: 26.07, lon: 119.30 },
            { name: 'Hefei', lat: 31.82, lon: 117.23 },
            { name: 'Changchun', lat: 43.88, lon: 125.32 },
            { name: 'Ürümqi', lat: 43.83, lon: 87.60 },
            { name: 'Nanning', lat: 22.82, lon: 108.32 },
            { name: 'Guiyang', lat: 26.65, lon: 106.63 },
            { name: 'Shijiazhuang', lat: 38.04, lon: 114.51 },
            { name: 'Taiyuan', lat: 37.87, lon: 112.55 },
            { name: 'Lanzhou', lat: 36.06, lon: 103.83 },
            { name: 'Nanchang', lat: 28.68, lon: 115.86 },
            { name: 'Suzhou', lat: 31.30, lon: 120.59 },
            { name: 'Xiamen', lat: 24.48, lon: 118.09 },
            { name: 'Ningbo', lat: 29.87, lon: 121.54 },
            { name: 'Wuxi', lat: 31.57, lon: 120.30 },
            { name: 'Foshan', lat: 23.02, lon: 113.12 },
            { name: 'Hong Kong', lat: 22.32, lon: 114.17 },
            // Japan
            { name: 'Tokyo', lat: 35.68, lon: 139.69 },
            { name: 'Osaka', lat: 34.69, lon: 135.50 },
            { name: 'Yokohama', lat: 35.44, lon: 139.64 },
            { name: 'Nagoya', lat: 35.18, lon: 136.91 },
            { name: 'Sapporo', lat: 43.06, lon: 141.35 },
            { name: 'Fukuoka', lat: 33.59, lon: 130.40 },
            { name: 'Kobe', lat: 34.69, lon: 135.20 },
            { name: 'Kyoto', lat: 35.01, lon: 135.77 },
            { name: 'Kawasaki', lat: 35.52, lon: 139.72 },
            // South Korea
            { name: 'Seoul', lat: 37.57, lon: 126.98 },
            { name: 'Busan', lat: 35.18, lon: 129.08 },
            { name: 'Incheon', lat: 37.46, lon: 126.71 },
            { name: 'Daegu', lat: 35.87, lon: 128.60 },
            { name: 'Daejeon', lat: 36.35, lon: 127.38 },
            // Taiwan
            { name: 'Taipei', lat: 25.03, lon: 121.57 },
            { name: 'Kaohsiung', lat: 22.63, lon: 120.30 },
            // Mongolia
            { name: 'Ulaanbaatar', lat: 47.92, lon: 106.92 },
            // Southeast Asia
            { name: 'Jakarta', lat: -6.21, lon: 106.85 },
            { name: 'Bangkok', lat: 13.76, lon: 100.50 },
            { name: 'Ho Chi Minh City', lat: 10.82, lon: 106.63 },
            { name: 'Hanoi', lat: 21.03, lon: 105.85 },
            { name: 'Singapore', lat: 1.29, lon: 103.85 },
            { name: 'Kuala Lumpur', lat: 3.14, lon: 101.69 },
            { name: 'Manila', lat: 14.60, lon: 120.98 },
            { name: 'Yangon', lat: 16.87, lon: 96.20 },
            { name: 'Phnom Penh', lat: 11.56, lon: 104.92 },
            { name: 'Surabaya', lat: -7.25, lon: 112.75 },
            { name: 'Bandung', lat: -6.91, lon: 107.61 },
            { name: 'Medan', lat: 3.59, lon: 98.67 },
            { name: 'Semarang', lat: -6.97, lon: 110.42 },
            { name: 'Makassar', lat: -5.14, lon: 119.42 },
            { name: 'Quezon City', lat: 14.68, lon: 121.03 },
            { name: 'Davao', lat: 7.07, lon: 125.61 },
            // South Asia — India
            { name: 'Mumbai', lat: 19.08, lon: 72.88 },
            { name: 'Delhi', lat: 28.61, lon: 77.21 },
            { name: 'Bangalore', lat: 12.97, lon: 77.59 },
            { name: 'Hyderabad', lat: 17.38, lon: 78.49 },
            { name: 'Ahmedabad', lat: 23.02, lon: 72.57 },
            { name: 'Chennai', lat: 13.08, lon: 80.27 },
            { name: 'Kolkata', lat: 22.57, lon: 88.36 },
            { name: 'Pune', lat: 18.52, lon: 73.86 },
            { name: 'Jaipur', lat: 26.91, lon: 75.79 },
            { name: 'Lucknow', lat: 26.85, lon: 80.95 },
            { name: 'Kanpur', lat: 26.45, lon: 80.33 },
            { name: 'Nagpur', lat: 21.15, lon: 79.09 },
            { name: 'Indore', lat: 22.72, lon: 75.86 },
            { name: 'Patna', lat: 25.61, lon: 85.14 },
            { name: 'Bhopal', lat: 23.26, lon: 77.41 },
            { name: 'Surat', lat: 21.17, lon: 72.83 },
            { name: 'Visakhapatnam', lat: 17.69, lon: 83.22 },
            { name: 'Varanasi', lat: 25.32, lon: 83.01 },
            { name: 'Coimbatore', lat: 11.01, lon: 76.96 },
            { name: 'Vadodara', lat: 22.31, lon: 73.19 },
            { name: 'Ludhiana', lat: 30.90, lon: 75.86 },
            { name: 'Agra', lat: 27.18, lon: 78.02 },
            { name: 'Nashik', lat: 19.99, lon: 73.79 },
            { name: 'Rajkot', lat: 22.30, lon: 70.80 },
            { name: 'Ranchi', lat: 23.36, lon: 85.33 },
            { name: 'Amritsar', lat: 31.63, lon: 74.87 },
            // Pakistan
            { name: 'Karachi', lat: 24.86, lon: 67.01 },
            { name: 'Lahore', lat: 31.55, lon: 74.35 },
            { name: 'Faisalabad', lat: 31.42, lon: 73.08 },
            { name: 'Rawalpindi', lat: 33.60, lon: 73.05 },
            { name: 'Multan', lat: 30.20, lon: 71.45 },
            { name: 'Peshawar', lat: 34.01, lon: 71.58 },
            { name: 'Gujranwala', lat: 32.16, lon: 74.19 },
            // Bangladesh
            { name: 'Dhaka', lat: 23.81, lon: 90.41 },
            { name: 'Chittagong', lat: 22.36, lon: 91.78 },
            // Sri Lanka, Nepal
            { name: 'Colombo', lat: 6.93, lon: 79.85 },
            { name: 'Kathmandu', lat: 27.72, lon: 85.32 },
            // Central Asia
            { name: 'Tashkent', lat: 41.30, lon: 69.28 },
            { name: 'Almaty', lat: 43.24, lon: 76.95 },
            { name: 'Astana', lat: 51.17, lon: 71.43 },
            // Middle East — Turkey
            { name: 'Istanbul', lat: 41.01, lon: 28.98 },
            { name: 'Ankara', lat: 39.93, lon: 32.86 },
            { name: 'Izmir', lat: 38.42, lon: 27.14 },
            { name: 'Bursa', lat: 40.19, lon: 29.06 },
            { name: 'Antalya', lat: 36.90, lon: 30.70 },
            { name: 'Adana', lat: 37.00, lon: 35.33 },
            { name: 'Gaziantep', lat: 37.06, lon: 37.38 },
            // Iran
            { name: 'Tehran', lat: 35.69, lon: 51.39 },
            { name: 'Mashhad', lat: 36.30, lon: 59.60 },
            { name: 'Isfahan', lat: 32.65, lon: 51.68 },
            { name: 'Tabriz', lat: 38.08, lon: 46.29 },
            { name: 'Shiraz', lat: 29.59, lon: 52.58 },
            { name: 'Karaj', lat: 35.84, lon: 50.97 },
            // Iraq
            { name: 'Baghdad', lat: 33.31, lon: 44.37 },
            { name: 'Basra', lat: 30.51, lon: 47.81 },
            { name: 'Mosul', lat: 36.34, lon: 43.12 },
            // Arabian Peninsula
            { name: 'Riyadh', lat: 24.69, lon: 46.72 },
            { name: 'Jeddah', lat: 21.54, lon: 39.17 },
            { name: 'Mecca', lat: 21.39, lon: 39.86 },
            { name: 'Dubai', lat: 25.20, lon: 55.27 },
            { name: 'Sanaa', lat: 15.35, lon: 44.21 },
            { name: 'Kuwait City', lat: 29.38, lon: 47.99 },
            // Levant & Caucasus
            { name: 'Amman', lat: 31.95, lon: 35.93 },
            { name: 'Damascus', lat: 33.51, lon: 36.29 },
            { name: 'Aleppo', lat: 36.20, lon: 37.16 },
            { name: 'Tel Aviv', lat: 32.09, lon: 34.78 },
            { name: 'Beirut', lat: 33.89, lon: 35.50 },
            { name: 'Baku', lat: 40.41, lon: 49.87 },
            { name: 'Tbilisi', lat: 41.72, lon: 44.79 },
            { name: 'Yerevan', lat: 40.18, lon: 44.51 },
            // Africa — North
            { name: 'Cairo', lat: 30.04, lon: 31.24 },
            { name: 'Alexandria', lat: 31.20, lon: 29.92 },
            { name: 'Algiers', lat: 36.74, lon: 3.06 },
            { name: 'Casablanca', lat: 33.57, lon: -7.59 },
            { name: 'Rabat', lat: 34.02, lon: -6.83 },
            { name: 'Fes', lat: 34.03, lon: -5.00 },
            { name: 'Tunis', lat: 36.81, lon: 10.18 },
            { name: 'Tripoli', lat: 32.90, lon: 13.18 },
            { name: 'Khartoum', lat: 15.59, lon: 32.53 },
            // West Africa
            { name: 'Lagos', lat: 6.52, lon: 3.38 },
            { name: 'Kano', lat: 12.00, lon: 8.51 },
            { name: 'Ibadan', lat: 7.38, lon: 3.94 },
            { name: 'Abuja', lat: 9.06, lon: 7.49 },
            { name: 'Accra', lat: 5.56, lon: -0.19 },
            { name: 'Abidjan', lat: 5.32, lon: -4.00 },
            { name: 'Dakar', lat: 14.69, lon: -17.44 },
            { name: 'Bamako', lat: 12.64, lon: -8.00 },
            { name: 'Ouagadougou', lat: 12.37, lon: -1.52 },
            { name: 'Conakry', lat: 9.64, lon: -13.58 },
            { name: 'Douala', lat: 4.05, lon: 9.77 },
            { name: 'Yaoundé', lat: 3.87, lon: 11.52 },
            // East Africa
            { name: 'Addis Ababa', lat: 9.03, lon: 38.75 },
            { name: 'Nairobi', lat: -1.29, lon: 36.82 },
            { name: 'Dar es Salaam', lat: -6.79, lon: 39.28 },
            { name: 'Kampala', lat: 0.32, lon: 32.58 },
            { name: 'Mogadishu', lat: 2.05, lon: 45.32 },
            { name: 'Kigali', lat: -1.94, lon: 30.06 },
            // Central & Southern Africa
            { name: 'Kinshasa', lat: -4.32, lon: 15.31 },
            { name: 'Luanda', lat: -8.84, lon: 13.23 },
            { name: 'Johannesburg', lat: -26.20, lon: 28.05 },
            { name: 'Cape Town', lat: -33.93, lon: 18.42 },
            { name: 'Durban', lat: -29.86, lon: 31.02 },
            { name: 'Lusaka', lat: -15.39, lon: 28.32 },
            { name: 'Harare', lat: -17.83, lon: 31.05 },
            { name: 'Maputo', lat: -25.97, lon: 32.58 },
            { name: 'Antananarivo', lat: -18.88, lon: 47.51 },
            // Europe — Russia
            { name: 'Moscow', lat: 55.76, lon: 37.62 },
            { name: 'St Petersburg', lat: 59.93, lon: 30.32 },
            { name: 'Novosibirsk', lat: 55.01, lon: 82.92 },
            { name: 'Yekaterinburg', lat: 56.84, lon: 60.60 },
            { name: 'Kazan', lat: 55.80, lon: 49.11 },
            { name: 'Nizhny Novgorod', lat: 56.30, lon: 44.00 },
            { name: 'Chelyabinsk', lat: 55.16, lon: 61.40 },
            { name: 'Samara', lat: 53.19, lon: 50.10 },
            { name: 'Rostov-on-Don', lat: 47.24, lon: 39.71 },
            { name: 'Ufa', lat: 54.74, lon: 55.97 },
            { name: 'Krasnoyarsk', lat: 56.01, lon: 92.87 },
            { name: 'Perm', lat: 58.01, lon: 56.25 },
            { name: 'Voronezh', lat: 51.67, lon: 39.18 },
            { name: 'Volgograd', lat: 48.72, lon: 44.50 },
            { name: 'Omsk', lat: 54.99, lon: 73.37 },
            // Western Europe
            { name: 'London', lat: 51.51, lon: -0.13 },
            { name: 'Birmingham', lat: 52.48, lon: -1.90 },
            { name: 'Paris', lat: 48.86, lon: 2.35 },
            { name: 'Berlin', lat: 52.52, lon: 13.41 },
            { name: 'Hamburg', lat: 53.55, lon: 10.00 },
            { name: 'Munich', lat: 48.14, lon: 11.58 },
            { name: 'Cologne', lat: 50.94, lon: 6.96 },
            { name: 'Madrid', lat: 40.42, lon: -3.70 },
            { name: 'Barcelona', lat: 41.39, lon: 2.17 },
            { name: 'Rome', lat: 41.90, lon: 12.50 },
            { name: 'Milan', lat: 45.46, lon: 9.19 },
            { name: 'Naples', lat: 40.85, lon: 14.27 },
            { name: 'Vienna', lat: 48.21, lon: 16.37 },
            { name: 'Amsterdam', lat: 52.37, lon: 4.90 },
            { name: 'Brussels', lat: 50.85, lon: 4.35 },
            { name: 'Lisbon', lat: 38.72, lon: -9.14 },
            { name: 'Stockholm', lat: 59.33, lon: 18.07 },
            { name: 'Dublin', lat: 53.35, lon: -6.26 },
            { name: 'Copenhagen', lat: 55.68, lon: 12.57 },
            { name: 'Helsinki', lat: 60.17, lon: 24.94 },
            { name: 'Oslo', lat: 59.91, lon: 10.75 },
            { name: 'Athens', lat: 37.98, lon: 23.73 },
            // Eastern Europe
            { name: 'Kyiv', lat: 50.45, lon: 30.52 },
            { name: 'Kharkiv', lat: 49.99, lon: 36.23 },
            { name: 'Bucharest', lat: 44.43, lon: 26.10 },
            { name: 'Warsaw', lat: 52.23, lon: 21.01 },
            { name: 'Budapest', lat: 47.50, lon: 19.04 },
            { name: 'Prague', lat: 50.08, lon: 14.44 },
            { name: 'Sofia', lat: 42.70, lon: 23.32 },
            { name: 'Belgrade', lat: 44.82, lon: 20.46 },
            { name: 'Minsk', lat: 53.90, lon: 27.57 },
            // North America — USA
            { name: 'New York', lat: 40.71, lon: -74.01 },
            { name: 'Los Angeles', lat: 34.05, lon: -118.24 },
            { name: 'Chicago', lat: 41.88, lon: -87.63 },
            { name: 'Houston', lat: 29.76, lon: -95.37 },
            { name: 'Phoenix', lat: 33.45, lon: -112.07 },
            { name: 'Philadelphia', lat: 39.95, lon: -75.17 },
            { name: 'San Antonio', lat: 29.42, lon: -98.49 },
            { name: 'San Diego', lat: 32.72, lon: -117.16 },
            { name: 'Dallas', lat: 32.78, lon: -96.80 },
            { name: 'San Jose', lat: 37.34, lon: -121.89 },
            { name: 'Austin', lat: 30.27, lon: -97.74 },
            { name: 'San Francisco', lat: 37.77, lon: -122.42 },
            // Canada
            { name: 'Toronto', lat: 43.65, lon: -79.38 },
            { name: 'Montreal', lat: 45.50, lon: -73.57 },
            { name: 'Vancouver', lat: 49.28, lon: -123.12 },
            { name: 'Calgary', lat: 51.05, lon: -114.07 },
            { name: 'Edmonton', lat: 53.55, lon: -113.49 },
            { name: 'Ottawa', lat: 45.42, lon: -75.70 },
            // Mexico
            { name: 'Mexico City', lat: 19.43, lon: -99.13 },
            { name: 'Guadalajara', lat: 20.67, lon: -103.35 },
            { name: 'Monterrey', lat: 25.67, lon: -100.31 },
            { name: 'Puebla', lat: 19.04, lon: -98.20 },
            { name: 'Tijuana', lat: 32.51, lon: -117.02 },
            { name: 'León', lat: 21.12, lon: -101.68 },
            // Caribbean & Central America
            { name: 'Havana', lat: 23.11, lon: -82.37 },
            { name: 'Santo Domingo', lat: 18.49, lon: -69.93 },
            { name: 'Guatemala City', lat: 14.63, lon: -90.51 },
            { name: 'Panama City', lat: 8.98, lon: -79.52 },
            // South America
            { name: 'São Paulo', lat: -23.55, lon: -46.63 },
            { name: 'Rio de Janeiro', lat: -22.91, lon: -43.17 },
            { name: 'Brasília', lat: -15.79, lon: -47.88 },
            { name: 'Salvador', lat: -12.97, lon: -38.51 },
            { name: 'Fortaleza', lat: -3.72, lon: -38.53 },
            { name: 'Belo Horizonte', lat: -19.92, lon: -43.94 },
            { name: 'Manaus', lat: -3.12, lon: -60.02 },
            { name: 'Curitiba', lat: -25.43, lon: -49.27 },
            { name: 'Recife', lat: -8.05, lon: -34.87 },
            { name: 'Porto Alegre', lat: -30.03, lon: -51.23 },
            { name: 'Belém', lat: -1.46, lon: -48.50 },
            { name: 'Goiânia', lat: -16.68, lon: -49.26 },
            { name: 'Buenos Aires', lat: -34.60, lon: -58.38 },
            { name: 'Córdoba', lat: -31.42, lon: -64.18 },
            { name: 'Rosario', lat: -32.95, lon: -60.65 },
            { name: 'Lima', lat: -12.05, lon: -77.04 },
            { name: 'Bogotá', lat: 4.71, lon: -74.07 },
            { name: 'Medellín', lat: 6.25, lon: -75.56 },
            { name: 'Cali', lat: 3.44, lon: -76.52 },
            { name: 'Barranquilla', lat: 10.96, lon: -74.78 },
            { name: 'Santiago', lat: -33.45, lon: -70.67 },
            { name: 'Caracas', lat: 10.49, lon: -66.88 },
            { name: 'Maracaibo', lat: 10.63, lon: -71.63 },
            { name: 'Quito', lat: -0.18, lon: -78.47 },
            { name: 'Guayaquil', lat: -2.17, lon: -79.92 },
            { name: 'La Paz', lat: -16.50, lon: -68.15 },
            { name: 'Santa Cruz', lat: -17.78, lon: -63.18 },
            { name: 'Montevideo', lat: -34.90, lon: -56.19 },
            { name: 'Asunción', lat: -25.26, lon: -57.58 },
            // Oceania
            { name: 'Sydney', lat: -33.87, lon: 151.21 },
            { name: 'Melbourne', lat: -37.81, lon: 144.96 },
            { name: 'Brisbane', lat: -27.47, lon: 153.03 },
            { name: 'Perth', lat: -31.95, lon: 115.86 },
            { name: 'Adelaide', lat: -34.93, lon: 138.60 },
            { name: 'Auckland', lat: -36.85, lon: 174.76 }
        ];

        // Fetch mean daytime temperatures for all major cities on a given date
        async function fetchCityTemperatures(dateStr) {
            const today = new Date();
            const target = new Date(dateStr + 'T00:00:00');
            const diffDays = Math.round((target - today) / (1000 * 60 * 60 * 24));
            const isHistorical = diffDays < -5;
            const baseUrl = isHistorical
                ? 'https://archive-api.open-meteo.com/v1/archive'
                : 'https://api.open-meteo.com/v1/forecast';

            // Batch cities into groups of 50 (URL length limits)
            const batchSize = 50;
            const results = [];
            const batches = [];
            for (let i = 0; i < majorCities.length; i += batchSize) {
                batches.push(majorCities.slice(i, i + batchSize));
            }

            // Fetch all batches in parallel
            const batchResults = await Promise.all(batches.map(async (batch) => {
                try {
                    const lats = batch.map(c => c.lat).join(',');
                    const lons = batch.map(c => c.lon).join(',');
                    const url = `${baseUrl}?latitude=${lats}&longitude=${lons}&hourly=temperature_2m,is_day&start_date=${dateStr}&end_date=${dateStr}&timezone=auto`;
                    const resp = await fetch(url);
                    return { status: 'fulfilled', value: { batch, json: await resp.json() } };
                } catch (e) {
                    return { status: 'rejected' };
                }
            }));

            batchResults.forEach(result => {
                if (result.status === 'fulfilled') {
                    const { batch, json } = result.value;
                    const items = Array.isArray(json) ? json : [json];
                    items.forEach((item, idx) => {
                        const cap = batch[idx];
                        let meanTempC = null;
                        if (item.hourly && item.hourly.temperature_2m && item.hourly.is_day) {
                            let s = 0, c = 0;
                            for (let h = 0; h < item.hourly.temperature_2m.length; h++) {
                                if (item.hourly.is_day[h]) {
                                    s += item.hourly.temperature_2m[h];
                                    c++;
                                }
                            }
                            if (c > 0) meanTempC = s / c;
                        }
                        results.push({ name: cap.name, lat: cap.lat, lon: cap.lon, meanTempC });
                    });
                } else {
                    console.error('Batch fetch failed:', result.reason);
                }
            });
            return results;
        }
        */ // end similar button comment

        // Handle keyboard navigation for days
        document.addEventListener('keydown', async (e) => {
            if (e.key === 'ArrowLeft') {
                currentDayOffset--;
                await refreshView();
                // Prefetch more past days if approaching the boundary
                if (currentDayOffset <= prefetchedPastBoundary + 3) {
                    prefetchPastDays(currentCity, prefetchedPastBoundary);
                }
            } else if (e.key === 'ArrowRight') {
                if (currentDayOffset < maxFutureOffset) {
                    currentDayOffset++;
                    await refreshView();
                    if (currentDayOffset >= maxFutureOffset) {
                        showForecastLimitMessage();
                    }
                } else {
                    showForecastLimitMessage();
                }
            }
        });

        // Temperature tooltip on mousemove
        const tempOverlay = document.getElementById('tempCurveOverlay');
        const tempTooltip = document.getElementById('tempTooltip');

        // Position the overlay to cover from below sky tooltip area down to temperature curve
        function updateOverlayPosition() {
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const skyRibbonEl = document.getElementById('skyRibbon');
            const daySelectorEl = document.querySelector('.day-selector');
            const wrapperRect = wrapper.getBoundingClientRect();
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const daySelectorRect = daySelectorEl.getBoundingClientRect();
            const height = wrapperRect.height || window.innerHeight * 0.6;

            // Calculate sky ribbon position relative to wrapper
            const skyBottomInWrapper = (skyRect.bottom - wrapperRect.top);

            // Get sky ribbon bounds relative to the wrapper
            const ribbonLeft = skyRect.left - wrapperRect.left;
            const ribbonWidth = skyRect.width;
            const skyTopInWrapper = skyRect.top - wrapperRect.top;

            // Sky tooltip stops at 144px from top of sky ribbon
            const visibleSkyHeight = 144;
            const tempOverlayTop = skyTopInWrapper + visibleSkyHeight;

            // Match the temperature curve positioning exactly as in drawTemperatureCurve()
            const curveHeight = Math.min(height * 0.396, 216);
            const curveBottom = skyBottomInWrapper + curveHeight * 0.8 - 160;

            // Stop overlay before the day selector (with 10px buffer)
            const daySelectorTopInWrapper = daySelectorRect.top - wrapperRect.top;
            const overlayBottom = Math.min(curveBottom + 20, daySelectorTopInWrapper - 10);

            // Ensure positive height, hide if invalid
            const overlayHeight = Math.max(0, overlayBottom - tempOverlayTop);

            tempOverlay.style.left = `${ribbonLeft}px`;
            tempOverlay.style.top = `${tempOverlayTop}px`;
            tempOverlay.style.width = `${ribbonWidth}px`;
            tempOverlay.style.height = `${overlayHeight}px`;
        }

        updateOverlayPosition();
        window.addEventListener('resize', updateOverlayPosition);

        tempOverlay.addEventListener('mousemove', (e) => {
            // Get sky ribbon bounds in screen coordinates (for mouse position comparison)
            const skyRibbonEl = document.getElementById('skyRibbon');
            const daySelectorEl = document.querySelector('.day-selector');
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const daySelectorRect = daySelectorEl.getBoundingClientRect();
            const ribbonLeft = skyRect.left;  // Screen coordinates for mouse comparison
            const ribbonWidth = skyRect.width;

            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Hide tooltip if mouse is at or below the day selector
            if (mouseY >= daySelectorRect.top - 10) {
                tempTooltip.style.display = 'none';
                return;
            }

            // Calculate position along the ribbon (0 to 1)
            const t = (mouseX - ribbonLeft) / ribbonWidth;

            // Calculate hour from position (map t from display range to full 24h)
            const displayHours = displayEndHour - displayStartHour;
            const hour = Math.round(displayStartHour + t * displayHours);
            const hourStr = `${hour}h`;

            // Get temperature value using the same interpolation as the curve
            const tempNorm = interpolateDataSmooth(weatherData.temperature, t, true);

            // Convert normalized temperature back to Celsius
            // Normalization was: (temp + 25) / 60, so reverse: temp = norm * 60 - 25
            const tempCelsius = tempNorm * 60 - 25;

            // Get color for this temperature
            const tempColor = getTempColor(tempNorm);

            // Get wind data
            const windSpeedKmh = weatherData.windSpeedRaw ? interpolateData(weatherData.windSpeedRaw, t) : 0;

            // Build tooltip content
            let tempInfo = `<span style="color: rgb(${tempColor.r}, ${tempColor.g}, ${tempColor.b})">${Math.round(tempCelsius)}°C</span>`;
            if (windSpeedKmh > 15) {
                tempInfo += ` | ${Math.round(windSpeedKmh)} km/h wind`;
            }

            // Display the tooltip with hour on first line, temperature on second
            tempTooltip.innerHTML = `<div class="tooltip-hour">${hourStr}</div><div class="tooltip-value">${tempInfo}</div>`;
            tempTooltip.style.left = `${mouseX}px`;
            tempTooltip.style.top = `${mouseY}px`;
            tempTooltip.style.display = 'block';
        });

        tempOverlay.addEventListener('mouseleave', () => {
            tempTooltip.style.display = 'none';
        });

        // Touch device detection
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Sky tooltip on mousemove (desktop only - disabled on touch to allow tap navigation)
        const skyRibbon = document.getElementById('skyRibbon');
        const skyTooltip = document.getElementById('skyTooltip');

        if (!isTouchDevice) {
            skyRibbon.addEventListener('mousemove', (e) => {
                const rect = skyRibbon.getBoundingClientRect();
                const mouseX = e.clientX;
                const mouseY = e.clientY;

                // Calculate the sky portion height (excluding precipitation extension)
                // Sky portion ends at skyFadeEndY which is fullBaseHeight + skyExtensionHeight
                // But we display from cropAmount, so visible sky height is:
                // skyFadeEndY - cropAmount = (240 + 36) - (240 * 0.55) = 276 - 132 = 144px
                const visibleSkyHeight = 144; // Approximate visible sky height before precipitation area
                const skyBottomY = rect.top + visibleSkyHeight;

                // Hide tooltip when mouse is below the sky portion (in precipitation area)
                // This prevents interference with the temperature curve overlay
                if (mouseY > skyBottomY) {
                    skyTooltip.style.display = 'none';
                    return;
                }

                // Calculate position along the ribbon (0 to 1)
                const t = (mouseX - rect.left) / rect.width;

                // Calculate hour from position (map t from display range to full 24h)
                const displayHours = displayEndHour - displayStartHour;
                const hour = Math.round(displayStartHour + t * displayHours);
                const hourStr = `${hour}h`;

                // Get cloud cover value and daylight for color calculation
                const cloudValue = interpolateData(weatherData.clouds, t);
                const cloudPercent = Math.round(cloudValue * 100);
                const dayValue = interpolateData(weatherData.daylight, t);

                // Get precipitation data
                const precipMm = interpolateData(weatherData.precipMm, t);
                const precipProb = interpolateData(weatherData.precipProbability, t);
                const snowCm = weatherData.snowCm ? interpolateData(weatherData.snowCm, t) : 0;

                // Build tooltip text for weather info with color
                let cloudText, cloudColor;
                if (cloudPercent < 20) {
                    // Clear sky - show in blue
                    cloudText = 'clear sky';
                    cloudColor = 'rgb(100, 180, 235)';
                } else {
                    // Cloudy - use daytime gray color (always bright, regardless of time of day)
                    const rainValue = interpolateData(weatherData.rain, t);
                    const baseGray = Math.round(230 - cloudValue * 30 - rainValue * 40);
                    cloudText = `${cloudPercent}% clouds`;
                    cloudColor = `rgb(${baseGray}, ${baseGray}, ${baseGray})`;
                }

                let weatherInfo = `<span style="color: ${cloudColor}">${cloudText}</span>`;

                // Add precipitation info if there's any rain or snow
                if (snowCm > 0.1) {
                    // Show snow in white
                    weatherInfo += ` | <span style="color: rgb(255, 255, 255)">${snowCm.toFixed(1)}cm snow</span>`;
                } else if (precipMm > 0.1) {
                    // Show rain in blue
                    weatherInfo += ` | <span style="color: rgb(100, 180, 235)">${precipMm.toFixed(1)}mm rain</span>`;
                }

                // Add sunrise/sunset info if within 1 hour
                const currentHour = displayStartHour + t * (displayEndHour - displayStartHour);
                const sunriseHour = weatherData.sunriseHour;
                const sunsetHour = weatherData.sunsetHour;

                if (Math.abs(currentHour - sunriseHour) <= 1) {
                    // Get sky color at sunrise time
                    const sunriseDayValue = interpolateData(weatherData.daylight, (sunriseHour - displayStartHour) / (displayEndHour - displayStartHour));
                    const skyColor = getSkyColor(sunriseDayValue, 0);
                    const sunriseMinutes = Math.round((sunriseHour % 1) * 60);
                    const sunriseTimeStr = `${Math.floor(sunriseHour)}h${sunriseMinutes.toString().padStart(2, '0')}`;
                    weatherInfo += ` | <span style="color: rgb(${skyColor.bottom.r}, ${skyColor.bottom.g}, ${skyColor.bottom.b})">sunrise ${sunriseTimeStr}</span>`;
                } else if (Math.abs(currentHour - sunsetHour) <= 1) {
                    // Get sky color at sunset time
                    const sunsetDayValue = interpolateData(weatherData.daylight, (sunsetHour - displayStartHour) / (displayEndHour - displayStartHour));
                    const skyColor = getSkyColor(sunsetDayValue, 0);
                    const sunsetMinutes = Math.round((sunsetHour % 1) * 60);
                    const sunsetTimeStr = `${Math.floor(sunsetHour)}h${sunsetMinutes.toString().padStart(2, '0')}`;
                    weatherInfo += ` | <span style="color: rgb(${skyColor.bottom.r}, ${skyColor.bottom.g}, ${skyColor.bottom.b})">sunset ${sunsetTimeStr}</span>`;
                }

                // Display the tooltip with hour on first line, weather info on second
                skyTooltip.innerHTML = `<div class="tooltip-hour">${hourStr}</div><div class="tooltip-value">${weatherInfo}</div>`;
                skyTooltip.style.left = `${mouseX}px`;
                skyTooltip.style.top = `${mouseY}px`;
                skyTooltip.style.display = 'block';
            });

            skyRibbon.addEventListener('mouseleave', () => {
                skyTooltip.style.display = 'none';
            });

            // Hover title: show "weather flow" when mouse is above the sky ribbon
            const hoverTitle = document.getElementById('hoverTitle');
            let hoverTitleFadeTimer = null;

            document.addEventListener('mousemove', (e) => {
                if (!hoverTitle) return;
                const ribbon = document.getElementById('skyRibbon');
                if (!ribbon) return;
                const ribbonRect = ribbon.getBoundingClientRect();

                // Above the sky ribbon = from viewport top to ribbon top
                const isAboveRibbon = e.clientY < ribbonRect.top &&
                                      e.clientX >= ribbonRect.left &&
                                      e.clientX <= ribbonRect.right;

                if (isAboveRibbon) {
                    // Show title
                    if (hoverTitleFadeTimer) {
                        clearTimeout(hoverTitleFadeTimer);
                        hoverTitleFadeTimer = null;
                    }
                    hoverTitle.classList.add('visible');
                } else if (hoverTitle.classList.contains('visible')) {
                    // Schedule fade out after delay
                    if (!hoverTitleFadeTimer) {
                        hoverTitleFadeTimer = setTimeout(() => {
                            hoverTitle.classList.remove('visible');
                            hoverTitleFadeTimer = null;
                        }, 2000);
                    }
                }
            });
        }

        if (isTouchDevice) {
            document.body.classList.add('touch-device');

            // Show tap indicator briefly, then hide it
            const swipeIndicator = document.getElementById('swipeIndicator');
            setTimeout(() => {
                swipeIndicator.classList.add('hidden');
            }, 3000);

            // Tap left/right side of sky ribbon to navigate days
            const skyRibbonTouch = document.getElementById('skyRibbon');
            let touchStartX = 0, touchStartY = 0;

            skyRibbonTouch.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            skyRibbonTouch.addEventListener('touchend', async (e) => {
                const touchEndX = e.changedTouches[0].screenX;
                const touchEndY = e.changedTouches[0].screenY;
                const deltaX = Math.abs(touchEndX - touchStartX);
                const deltaY = Math.abs(touchEndY - touchStartY);

                // Only trigger on tap (minimal movement), not drag/scroll
                if (deltaX > 20 || deltaY > 20) return;

                const rect = skyRibbonTouch.getBoundingClientRect();
                const tapX = touchEndX - rect.left;
                const ribbonWidth = rect.width;

                // Tap on left third = previous day, right third = next day
                if (tapX < ribbonWidth * 0.33) {
                    currentDayOffset--;
                    await refreshView();
                    // Prefetch more past days if approaching the boundary
                    if (currentDayOffset <= prefetchedPastBoundary + 3) {
                        prefetchPastDays(currentCity, prefetchedPastBoundary);
                    }
                } else if (tapX > ribbonWidth * 0.67) {
                    if (currentDayOffset < maxFutureOffset) {
                        currentDayOffset++;
                        await refreshView();
                        if (currentDayOffset >= maxFutureOffset) {
                            showForecastLimitMessage();
                        }
                    } else {
                        showForecastLimitMessage();
                    }
                }
            }, { passive: true });
        } else {
            // Hide tap indicator on non-touch devices
            const swipeIndicator = document.getElementById('swipeIndicator');
            swipeIndicator.style.display = 'none';
        }

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js').catch(err => {
                console.log('Service worker registration failed:', err);
            });
        }

        // Initialize year band click/hover interaction
        initYearBandInteraction();
        initYearBandHover();

        // Fast initial load: show UI immediately, fetch only today, render, then background work
        updateCityLabel();
        updateDayLabel();

        (async () => {
            const splash = document.getElementById('splashTitle');
            try {
                // Single API call for today's data
                await updateWeatherData(currentCity, 0);

                // Calculate temp range from today's data (synchronous, no extra API call)
                calculateTempRangeFromData(fullWeatherData);
                tempRangeCity = currentCity;

                // Render
                draw();

                // Show day selector now that layout is stable
                document.querySelector('.day-selector').classList.add('visible');
            } catch (e) {
                console.error('Initial load failed:', e);
                // Show day selector even on error
                document.querySelector('.day-selector').classList.add('visible');
            }

            // Fade out splash title
            if (splash) {
                splash.classList.add('hidden');
                setTimeout(() => splash.remove(), 600);
            }

            // Background: refine temp range, year band, prefetch
            refineTempRangeInBackground(currentCity);
            yearBandCity = currentCity;
            fetchYearBandData(currentCity).then(() => drawYearBand());
            prefetchRemainingDays(currentCity);
        })();

        // Auto-refresh every hour to keep weather data current
        setInterval(() => {
            console.log('Auto-refreshing weather data...');
            currentDayOffset = 0; // Reset to current day
            refreshView();
        }, 60 * 60 * 1000); // 1 hour in milliseconds
    </script>
</body>
</html>
