<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Weather Flow</title>

    <!-- PWA Meta Tags -->
    <meta name="application-name" content="Weather Flow">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Weather Flow">
    <meta name="theme-color" content="#0d1117">
    <meta name="description" content="Beautiful weather visualization with flowing ribbons">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Icons -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(160deg, #0d1117 0%, #161b22 40%, #1a2332 70%, #0f1a2e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 0 20px;
            padding-top: 5vh;
            position: relative;
            /* Prevent horizontal scroll from swipe gestures */
            overflow-x: hidden;
        }

        /* Weather display wrapper - keeps sky and temperature together as one unit */
        .weather-display-wrapper {
            position: relative;
            width: 100%;
            z-index: 1;
            overflow: visible;
            /* Padding reduced since temp curve moved up 200px */
            padding-bottom: 50px;
        }

        #tempCurveCanvas, #windCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        #tempCurveCanvas { z-index: 0; }
        #windCanvas { z-index: 1; }

        #tempCurveOverlay {
            position: absolute;
            pointer-events: auto;
            z-index: 10;
        }

        /* Tooltips - fixed on desktop for smooth tracking */
        .temp-tooltip, .sky-tooltip {
            position: fixed;
        }

        /* On touch devices, everything in the wrapper scrolls together */
        .touch-device .weather-display-wrapper .temp-tooltip,
        .touch-device .weather-display-wrapper .sky-tooltip {
            position: absolute;
        }

        /* Disable temp overlay on touch devices to avoid interference with day navigation taps */
        .touch-device #tempCurveOverlay {
            pointer-events: none;
        }


        .container {
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: relative;
            z-index: 2;
            /* Position the sky ribbon at the top of the wrapper */
            padding-top: 10px;
        }

        .ribbon-row {
            display: flex;
            align-items: flex-start;
        }

        .ribbon-wrapper {
            flex: 1;
            height: 100px;
            position: relative;
            border-radius: 50px;
            overflow: hidden;
        }

        .ribbon-wrapper.dynamic-height {
            height: auto;
            min-height: 100px;
            border-radius: 50px 50px 0 0;
        }

        .ribbon-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .day-selector {
            display: flex;
            justify-content: center;
            align-items: center;
            position: absolute;
            bottom: 9px;
            left: 0;
            right: 0;
            z-index: 10;
        }

        .day-selector-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            position: relative;
        }

        .selector-divider {
            width: 1px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
        }

        .location-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .random-btn {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            color: rgba(180, 190, 210, 0.7);
            font-size: 0.7rem;
            padding: 4px 10px;
            cursor: pointer;
            transition: all 0.25s ease;
            letter-spacing: 0.5px;
        }

        .random-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.15);
            color: #e8eaef;
        }

        .date-nav {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .city-label, .day-label {
            cursor: pointer;
            padding: 6px 12px;
            border-radius: 15px;
            transition: all 0.25s ease;
            text-align: center;
            letter-spacing: 0.5px;
        }
        .city-label:hover, .day-label:hover {
            background: rgba(255, 255, 255, 0.08);
        }
        .city-label {
            color: rgba(235, 238, 245, 0.9);
            font-size: 0.9rem;
            min-width: 120px;
            position: relative;
        }
        .city-label:hover { color: #fff; }

        .set-default-btn {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 4px;
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            padding: 4px 12px;
            transition: all 0.25s ease;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
            white-space: nowrap;
        }
        .set-default-btn:hover {
            color: rgba(255, 255, 255, 0.9);
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .city-input {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            color: #fff;
            font-size: 0.9rem;
            letter-spacing: 1px;
            padding: 6px 12px;
            outline: none;
            width: 150px;
        }

        .city-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .city-input-wrapper {
            position: relative;
            min-width: 120px;
            text-align: center;
        }

        .city-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: rgba(30, 40, 60, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            overflow: hidden;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .city-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.2s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .city-suggestion:last-child {
            border-bottom: none;
        }

        .city-suggestion:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .city-suggestion-name {
            color: #fff;
            font-size: 0.9rem;
        }

        .city-suggestion-detail {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.75rem;
            margin-left: 4px;
        }

        .day-arrow {
            width: 36px;
            height: 36px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.06);
            color: rgba(180, 190, 210, 0.8);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.25s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .day-arrow:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.15);
            color: #e8eaef;
        }

        .day-arrow:disabled {
            opacity: 0.25;
            cursor: not-allowed;
        }

        .day-label {
            color: rgba(235, 238, 245, 0.9);
            font-size: 0.9rem;
            min-width: 140px;
            text-align: center;
            white-space: nowrap;
        }
        .day-label:hover { color: #fff; }

        .temp-tooltip, .sky-tooltip {
            background: rgba(8, 12, 20, 0.85);
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 100;
            display: none;
            transform: translate(-50%, -100%);
            margin-top: -10px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            text-align: center;
            line-height: 1.4;
        }

        .tooltip-hour {
            font-size: 0.85rem;
            color: rgba(200, 210, 230, 0.8);
            margin-bottom: 2px;
        }

        .tooltip-value {
            font-size: 0.85rem;
        }

        /* Responsive styles for mobile */
        @media (max-width: 768px) {
            body {
                padding: 0 10px;
                padding-top: 3vh;
            }

            .container {
                padding-top: 5px;
            }

            .weather-display-wrapper {
                padding-bottom: 40px;
            }

            .day-selector {
                bottom: 9px;
            }

            .day-selector-content {
                gap: 12px;
            }

            .date-nav {
                gap: 6px;
            }

            .day-label {
                font-size: 0.8rem;
                min-width: 120px;
            }

            .city-label {
                font-size: 0.8rem;
                min-width: 80px;
            }

            .random-btn {
                font-size: 0.65rem;
                padding: 3px 8px;
            }

            .ribbon-wrapper {
                height: 80px;
            }

            .ribbon-wrapper.dynamic-height {
                min-height: 80px;
            }
        }

        /* Portrait smartphone layout */
        @media (max-width: 480px) and (orientation: portrait) {
            body {
                padding: 0 5px;
                padding-top: 2vh;
            }

            .container {
                padding-top: 5px;
            }

            .weather-display-wrapper {
                padding-bottom: 20px;
            }

            .day-selector {
                position: relative;
                bottom: auto;
                margin-top: 15px;
            }

            .day-selector-content {
                width: 100%;
                flex-direction: row;
                justify-content: space-between;
                padding: 0 15px;
                gap: 10px;
            }

            .date-nav {
                gap: 4px;
            }

            .day-label {
                font-size: 0.8rem;
                min-width: auto;
                text-align: left;
            }

            .city-label {
                font-size: 0.8rem;
                min-width: auto;
                text-align: right;
            }

            .location-section {
                gap: 6px;
            }

            .random-btn {
                font-size: 0.6rem;
                padding: 3px 6px;
            }

            .selector-divider {
                display: none;
            }
        }

        /* Landscape smartphone - keep centered layout */
        @media (max-width: 480px) and (orientation: landscape) {
            body {
                padding: 0 10px;
                padding-top: 2vh;
            }

            .day-selector {
                bottom: 0px;
            }

            .day-selector-content {
                gap: 10px;
            }

            .date-nav {
                gap: 4px;
            }

            .day-label, .city-label {
                font-size: 0.75rem;
            }

            .day-label {
                min-width: 100px;
            }

            .random-btn {
                font-size: 0.6rem;
                padding: 2px 6px;
            }
        }

        /* Hide arrows on touch devices */
        .touch-device .day-arrow {
            display: none;
        }

        .touch-device .date-nav {
            gap: 0;
        }

        /* Swipe indicator for touch devices */
        .swipe-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(180, 195, 220, 0.35);
            font-size: 0.7rem;
            letter-spacing: 0.5px;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .swipe-indicator.hidden {
            opacity: 0;
        }

        /* Loading state */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 50;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.visible {
            opacity: 1;
        }

        .loading-skeleton {
            position: absolute;
            top: 10px;
            left: 0;
            right: 0;
            height: 144px;
            border-radius: 50px 50px 0 0;
            background: linear-gradient(90deg,
                rgba(30, 40, 60, 0.6) 0%,
                rgba(50, 65, 90, 0.8) 50%,
                rgba(30, 40, 60, 0.6) 100%);
            background-size: 200% 100%;
            animation: shimmer 1.5s ease-in-out infinite;
            overflow: hidden;
        }

        .loading-skeleton::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg,
                transparent 0%,
                rgba(255, 255, 255, 0.03) 50%,
                transparent 100%);
        }

        .loading-curve {
            position: absolute;
            left: 0;
            right: 0;
            height: 80px;
            background: linear-gradient(90deg,
                rgba(80, 100, 140, 0.2) 0%,
                rgba(100, 130, 170, 0.4) 50%,
                rgba(80, 100, 140, 0.2) 100%);
            background-size: 200% 100%;
            animation: shimmer 1.5s ease-in-out infinite;
            animation-delay: 0.2s;
            mask-image: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%);
            -webkit-mask-image: linear-gradient(180deg, rgba(0,0,0,0.6) 0%, transparent 100%);
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

    </style>
</head>
<body>
    <div class="weather-display-wrapper" id="weatherDisplayWrapper">
        <div class="loading-overlay" id="loadingOverlay">
            <div class="loading-skeleton"></div>
            <div class="loading-curve" id="loadingCurve"></div>
        </div>
        <canvas id="tempCurveCanvas"></canvas>
        <canvas id="windCanvas"></canvas>
        <div id="tempCurveOverlay"></div>
        <div class="temp-tooltip" id="tempTooltip"></div>

        <div class="container">
            <div class="ribbon-row">
                <div class="ribbon-wrapper dynamic-height">
                    <canvas id="skyRibbon" class="ribbon-canvas"></canvas>
                </div>
            </div>
        </div>
        <div class="sky-tooltip" id="skyTooltip"></div>

        <div class="day-selector">
            <div class="day-selector-content">
                <div class="date-nav">
                    <button class="day-arrow" id="prevDay">&#8592;</button>
                    <span class="day-label" id="dayLabel">Today</span>
                    <button class="day-arrow" id="nextDay">&#8594;</button>
                </div>
                <span class="selector-divider"></span>
                <div class="location-section">
                    <span class="city-label" id="cityLabel">Tokyo</span>
                    <button class="random-btn" id="randomBtn">random</button>
                </div>
            </div>
        </div>
    </div>
    <div class="swipe-indicator" id="swipeIndicator">tap left/right of sky to change day</div>

    <script>
        // City coordinates for weather API
        const cities = {
            'tokyo': { name: 'Tokyo', lat: 35.68, lon: 139.69, timezone: 'Asia/Tokyo' },
            'riyadh': { name: 'Riyadh', lat: 24.69, lon: 46.72, timezone: 'Asia/Riyadh' },
            'baltimore': { name: 'Baltimore', lat: 39.29, lon: -76.61, timezone: 'America/New_York' },
            'mexico-city': { name: 'Mexico City', lat: 19.43, lon: -99.13, timezone: 'America/Mexico_City' },
            'brasilia': { name: 'Brasília', lat: -15.79, lon: -47.88, timezone: 'America/Sao_Paulo' },
            'abu-dhabi': { name: 'Abu Dhabi', lat: 24.45, lon: 54.37, timezone: 'Asia/Dubai' }
        };

        // World capitals for random selection
        const worldCapitals = [
            { name: 'Tokyo', lat: 35.68, lon: 139.69, timezone: 'Asia/Tokyo' },
            { name: 'Beijing', lat: 39.90, lon: 116.41, timezone: 'Asia/Shanghai' },
            { name: 'Seoul', lat: 37.57, lon: 126.98, timezone: 'Asia/Seoul' },
            { name: 'New Delhi', lat: 28.61, lon: 77.21, timezone: 'Asia/Kolkata' },
            { name: 'Bangkok', lat: 13.76, lon: 100.50, timezone: 'Asia/Bangkok' },
            { name: 'Jakarta', lat: -6.21, lon: 106.85, timezone: 'Asia/Jakarta' },
            { name: 'Manila', lat: 14.60, lon: 120.98, timezone: 'Asia/Manila' },
            { name: 'Singapore', lat: 1.29, lon: 103.85, timezone: 'Asia/Singapore' },
            { name: 'Kuala Lumpur', lat: 3.14, lon: 101.69, timezone: 'Asia/Kuala_Lumpur' },
            { name: 'Hanoi', lat: 21.03, lon: 105.85, timezone: 'Asia/Ho_Chi_Minh' },
            { name: 'Taipei', lat: 25.03, lon: 121.57, timezone: 'Asia/Taipei' },
            { name: 'Moscow', lat: 55.76, lon: 37.62, timezone: 'Europe/Moscow' },
            { name: 'London', lat: 51.51, lon: -0.13, timezone: 'Europe/London' },
            { name: 'Paris', lat: 48.86, lon: 2.35, timezone: 'Europe/Paris' },
            { name: 'Berlin', lat: 52.52, lon: 13.41, timezone: 'Europe/Berlin' },
            { name: 'Rome', lat: 41.90, lon: 12.50, timezone: 'Europe/Rome' },
            { name: 'Madrid', lat: 40.42, lon: -3.70, timezone: 'Europe/Madrid' },
            { name: 'Lisbon', lat: 38.72, lon: -9.14, timezone: 'Europe/Lisbon' },
            { name: 'Amsterdam', lat: 52.37, lon: 4.90, timezone: 'Europe/Amsterdam' },
            { name: 'Brussels', lat: 50.85, lon: 4.35, timezone: 'Europe/Brussels' },
            { name: 'Vienna', lat: 48.21, lon: 16.37, timezone: 'Europe/Vienna' },
            { name: 'Prague', lat: 50.08, lon: 14.44, timezone: 'Europe/Prague' },
            { name: 'Warsaw', lat: 52.23, lon: 21.01, timezone: 'Europe/Warsaw' },
            { name: 'Budapest', lat: 47.50, lon: 19.04, timezone: 'Europe/Budapest' },
            { name: 'Athens', lat: 37.98, lon: 23.73, timezone: 'Europe/Athens' },
            { name: 'Stockholm', lat: 59.33, lon: 18.07, timezone: 'Europe/Stockholm' },
            { name: 'Oslo', lat: 59.91, lon: 10.75, timezone: 'Europe/Oslo' },
            { name: 'Copenhagen', lat: 55.68, lon: 12.57, timezone: 'Europe/Copenhagen' },
            { name: 'Helsinki', lat: 60.17, lon: 24.94, timezone: 'Europe/Helsinki' },
            { name: 'Dublin', lat: 53.35, lon: -6.26, timezone: 'Europe/Dublin' },
            { name: 'Reykjavik', lat: 64.15, lon: -21.94, timezone: 'Atlantic/Reykjavik' },
            { name: 'Bern', lat: 46.95, lon: 7.45, timezone: 'Europe/Zurich' },
            { name: 'Washington D.C.', lat: 38.91, lon: -77.04, timezone: 'America/New_York' },
            { name: 'Ottawa', lat: 45.42, lon: -75.70, timezone: 'America/Toronto' },
            { name: 'Mexico City', lat: 19.43, lon: -99.13, timezone: 'America/Mexico_City' },
            { name: 'Havana', lat: 23.11, lon: -82.37, timezone: 'America/Havana' },
            { name: 'Guatemala City', lat: 14.63, lon: -90.51, timezone: 'America/Guatemala' },
            { name: 'San José', lat: 9.93, lon: -84.08, timezone: 'America/Costa_Rica' },
            { name: 'Panama City', lat: 8.98, lon: -79.52, timezone: 'America/Panama' },
            { name: 'Bogotá', lat: 4.71, lon: -74.07, timezone: 'America/Bogota' },
            { name: 'Caracas', lat: 10.49, lon: -66.88, timezone: 'America/Caracas' },
            { name: 'Lima', lat: -12.05, lon: -77.04, timezone: 'America/Lima' },
            { name: 'Quito', lat: -0.18, lon: -78.47, timezone: 'America/Guayaquil' },
            { name: 'La Paz', lat: -16.50, lon: -68.15, timezone: 'America/La_Paz' },
            { name: 'Santiago', lat: -33.45, lon: -70.67, timezone: 'America/Santiago' },
            { name: 'Buenos Aires', lat: -34.60, lon: -58.38, timezone: 'America/Argentina/Buenos_Aires' },
            { name: 'Montevideo', lat: -34.90, lon: -56.19, timezone: 'America/Montevideo' },
            { name: 'Brasília', lat: -15.79, lon: -47.88, timezone: 'America/Sao_Paulo' },
            { name: 'Cairo', lat: 30.04, lon: 31.24, timezone: 'Africa/Cairo' },
            { name: 'Nairobi', lat: -1.29, lon: 36.82, timezone: 'Africa/Nairobi' },
            { name: 'Cape Town', lat: -33.93, lon: 18.42, timezone: 'Africa/Johannesburg' },
            { name: 'Lagos', lat: 6.52, lon: 3.38, timezone: 'Africa/Lagos' },
            { name: 'Accra', lat: 5.56, lon: -0.19, timezone: 'Africa/Accra' },
            { name: 'Casablanca', lat: 33.57, lon: -7.59, timezone: 'Africa/Casablanca' },
            { name: 'Tunis', lat: 36.81, lon: 10.18, timezone: 'Africa/Tunis' },
            { name: 'Algiers', lat: 36.74, lon: 3.06, timezone: 'Africa/Algiers' },
            { name: 'Addis Ababa', lat: 9.03, lon: 38.75, timezone: 'Africa/Addis_Ababa' },
            { name: 'Riyadh', lat: 24.69, lon: 46.72, timezone: 'Asia/Riyadh' },
            { name: 'Dubai', lat: 25.20, lon: 55.27, timezone: 'Asia/Dubai' },
            { name: 'Tel Aviv', lat: 32.09, lon: 34.78, timezone: 'Asia/Jerusalem' },
            { name: 'Ankara', lat: 39.93, lon: 32.86, timezone: 'Europe/Istanbul' },
            { name: 'Tehran', lat: 35.69, lon: 51.39, timezone: 'Asia/Tehran' },
            { name: 'Islamabad', lat: 33.69, lon: 73.06, timezone: 'Asia/Karachi' },
            { name: 'Dhaka', lat: 23.81, lon: 90.41, timezone: 'Asia/Dhaka' },
            { name: 'Kathmandu', lat: 27.72, lon: 85.32, timezone: 'Asia/Kathmandu' },
            { name: 'Colombo', lat: 6.93, lon: 79.85, timezone: 'Asia/Colombo' },
            { name: 'Canberra', lat: -35.28, lon: 149.13, timezone: 'Australia/Sydney' },
            { name: 'Wellington', lat: -41.29, lon: 174.78, timezone: 'Pacific/Auckland' },
            { name: 'Suva', lat: -18.14, lon: 178.44, timezone: 'Pacific/Fiji' },
            { name: 'Ulaanbaatar', lat: 47.92, lon: 106.92, timezone: 'Asia/Ulaanbaatar' },
            { name: 'Pyongyang', lat: 39.04, lon: 125.76, timezone: 'Asia/Pyongyang' },
            { name: 'Phnom Penh', lat: 11.56, lon: 104.92, timezone: 'Asia/Phnom_Penh' },
            { name: 'Vientiane', lat: 17.97, lon: 102.63, timezone: 'Asia/Vientiane' },
            { name: 'Yangon', lat: 16.87, lon: 96.20, timezone: 'Asia/Yangon' },
            { name: 'Thimphu', lat: 27.47, lon: 89.64, timezone: 'Asia/Thimphu' },
            { name: 'Kabul', lat: 34.53, lon: 69.17, timezone: 'Asia/Kabul' },
            { name: 'Tashkent', lat: 41.30, lon: 69.28, timezone: 'Asia/Tashkent' },
            { name: 'Astana', lat: 51.17, lon: 71.43, timezone: 'Asia/Almaty' },
            { name: 'Tbilisi', lat: 41.72, lon: 44.79, timezone: 'Asia/Tbilisi' },
            { name: 'Yerevan', lat: 40.18, lon: 44.51, timezone: 'Asia/Yerevan' },
            { name: 'Baku', lat: 40.41, lon: 49.87, timezone: 'Asia/Baku' },
            { name: 'Kyiv', lat: 50.45, lon: 30.52, timezone: 'Europe/Kiev' },
            { name: 'Minsk', lat: 53.90, lon: 27.57, timezone: 'Europe/Minsk' },
            { name: 'Vilnius', lat: 54.69, lon: 25.28, timezone: 'Europe/Vilnius' },
            { name: 'Riga', lat: 56.95, lon: 24.11, timezone: 'Europe/Riga' },
            { name: 'Tallinn', lat: 59.44, lon: 24.75, timezone: 'Europe/Tallinn' },
            { name: 'Bucharest', lat: 44.43, lon: 26.10, timezone: 'Europe/Bucharest' },
            { name: 'Sofia', lat: 42.70, lon: 23.32, timezone: 'Europe/Sofia' },
            { name: 'Belgrade', lat: 44.82, lon: 20.46, timezone: 'Europe/Belgrade' },
            { name: 'Zagreb', lat: 45.81, lon: 15.98, timezone: 'Europe/Zagreb' },
            { name: 'Ljubljana', lat: 46.05, lon: 14.51, timezone: 'Europe/Ljubljana' },
            { name: 'Sarajevo', lat: 43.86, lon: 18.41, timezone: 'Europe/Sarajevo' },
            { name: 'Skopje', lat: 42.00, lon: 21.43, timezone: 'Europe/Skopje' },
            { name: 'Tirana', lat: 41.33, lon: 19.82, timezone: 'Europe/Tirane' },
            { name: 'Valletta', lat: 35.90, lon: 14.51, timezone: 'Europe/Malta' },
            { name: 'Nicosia', lat: 35.17, lon: 33.37, timezone: 'Asia/Nicosia' },
            { name: 'Luxembourg', lat: 49.61, lon: 6.13, timezone: 'Europe/Luxembourg' },
            { name: 'Monaco', lat: 43.73, lon: 7.42, timezone: 'Europe/Monaco' },
            { name: 'Andorra la Vella', lat: 42.51, lon: 1.52, timezone: 'Europe/Andorra' }
        ];

        // Cache for fetched weather data (keyed by city-dayOffset)
        const weatherCache = {};

        // Load saved default city from localStorage
        function loadDefaultCity() {
            try {
                const saved = localStorage.getItem('weatherFlow_defaultCity');
                if (saved) {
                    const cityData = JSON.parse(saved);
                    // Add to cities if not a built-in city
                    if (!cities[cityData.key]) {
                        cities[cityData.key] = cityData.data;
                    }
                    return cityData.key;
                }
            } catch (e) {
                console.log('Could not load saved city:', e);
            }
            return 'tokyo';
        }

        function saveDefaultCity(cityKey) {
            try {
                const cityData = {
                    key: cityKey,
                    data: cities[cityKey]
                };
                localStorage.setItem('weatherFlow_defaultCity', JSON.stringify(cityData));
            } catch (e) {
                console.log('Could not save default city:', e);
            }
        }

        // Current state
        let currentCity = loadDefaultCity();
        let currentDayOffset = 0; // 0 = today, positive = future, negative = past
        const maxFutureOffset = 14; // Today + 14 days ahead (API limit)
        const historyBatchSize = 7; // Days to prefetch when going back in time

        // Current weather data
        let fullWeatherData = null;
        let weatherData = {};

        // Helper to get date string for a given offset from today in city's timezone
        function getDateForOffset(city, dayOffset) {
            const now = new Date();
            const cityDateStr = now.toLocaleDateString('en-CA', { timeZone: city.timezone });
            const cityToday = new Date(cityDateStr + 'T00:00:00');
            const targetDate = new Date(cityToday);
            targetDate.setDate(targetDate.getDate() + dayOffset);
            return targetDate.toISOString().split('T')[0];
        }

        // Fetch weather data from Open-Meteo API (forecast or historical)
        async function fetchWeatherData(cityKey, dayOffset = 0) {
            const city = cities[cityKey];
            const dateStr = getDateForOffset(city, dayOffset);

            // Cache key uses the actual date to ensure correct data
            const cacheKey = `${cityKey}-${dateStr}`;

            // Return cached data if available and has all required fields
            if (weatherCache[cacheKey] && weatherCache[cacheKey].precipMm && weatherCache[cacheKey].snowCm) {
                return weatherCache[cacheKey];
            }

            // Use historical API for past dates (more than 5 days ago), forecast API otherwise
            // Historical API has ~5 day delay, so use forecast for recent past
            const isHistorical = dayOffset < -5;
            const baseUrl = isHistorical
                ? 'https://archive-api.open-meteo.com/v1/archive'
                : 'https://api.open-meteo.com/v1/forecast';

            // Historical API doesn't have precipitation_probability
            const hourlyParams = isHistorical
                ? 'temperature_2m,cloud_cover,rain,snowfall,precipitation,wind_speed_10m,wind_direction_10m'
                : 'temperature_2m,cloud_cover,rain,snowfall,precipitation,precipitation_probability,wind_speed_10m,wind_direction_10m,is_day';

            const url = `${baseUrl}?latitude=${city.lat}&longitude=${city.lon}&hourly=${hourlyParams}&daily=sunrise,sunset&timezone=${encodeURIComponent(city.timezone)}&start_date=${dateStr}&end_date=${dateStr}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                // Parse sunrise/sunset times to hours
                const sunriseTime = new Date(data.daily.sunrise[0]);
                const sunsetTime = new Date(data.daily.sunset[0]);
                const sunriseHour = sunriseTime.getHours() + sunriseTime.getMinutes() / 60;
                const sunsetHour = sunsetTime.getHours() + sunsetTime.getMinutes() / 60;

                // Generate daylight array based on sunrise/sunset using smooth cosine curve
                // This creates a natural bell curve for daylight intensity
                const daylight = [];
                const transitionDuration = 1.5; // hours for dawn/dusk transition
                for (let hour = 0; hour < 24; hour++) {
                    let value;
                    if (hour < sunriseHour - transitionDuration) {
                        // Full night before dawn
                        value = 0;
                    } else if (hour < sunriseHour + transitionDuration) {
                        // Dawn transition - smooth cosine curve from 0 to 1
                        const t = (hour - (sunriseHour - transitionDuration)) / (2 * transitionDuration);
                        value = 0.5 - 0.5 * Math.cos(t * Math.PI);
                    } else if (hour < sunsetHour - transitionDuration) {
                        // Full day
                        value = 1;
                    } else if (hour < sunsetHour + transitionDuration) {
                        // Dusk transition - smooth cosine curve from 1 to 0
                        const t = (hour - (sunsetHour - transitionDuration)) / (2 * transitionDuration);
                        value = 0.5 + 0.5 * Math.cos(t * Math.PI);
                    } else {
                        // Full night after dusk
                        value = 0;
                    }
                    daylight.push(value);
                }

                // Normalize cloud cover (0-100 -> 0-1)
                const clouds = data.hourly.cloud_cover.map(c => c / 100);

                // Use precipitation field as primary source (works for all forecast days)
                // precipitation = total water equivalent in mm (rain + melted snow)
                // Fall back to rain field if precipitation is not available
                const precipMm = data.hourly.precipitation || data.hourly.rain;

                // Normalize precipitation for visual rendering (mm -> 0-1, capped at 10mm = 1)
                // Use precipitation field instead of rain for consistent display across all days
                const rain = precipMm.map(p => Math.min(1, p / 10));

                // Normalize snowfall (cm -> 0-1, capped at 5cm = 1)
                const snowfall = data.hourly.snowfall.map(s => Math.min(1, s / 5));
                const hasSnow = snowfall.some(s => s > 0);
                // Keep raw snow values (cm) for display
                const snowCm = data.hourly.snowfall;

                // Normalize temperature (-25°C to 35°C -> 0 to 1)
                const temperature = data.hourly.temperature_2m.map(t => {
                    return Math.max(0, Math.min(1, (t + 25) / 60));
                });

                // Get precipitation probability (0-100%) - keep hourly array
                const precipProbability = data.hourly.precipitation_probability || new Array(24).fill(0);

                // Wind speed (km/h) - normalize to 0-1 (0 = calm, 1 = 80+ km/h strong wind)
                const windSpeedRaw = data.hourly.wind_speed_10m || new Array(24).fill(0);
                const windSpeed = windSpeedRaw.map(w => Math.min(1, w / 80));
                // Wind direction (degrees, 0 = North, 90 = East, etc.)
                const windDirection = data.hourly.wind_direction_10m || new Array(24).fill(0);

                const weatherData = {
                    daylight,
                    clouds,
                    rain,
                    precipMm,
                    snow: hasSnow ? snowfall : null,
                    snowCm,
                    temperature,
                    precipProbability,
                    windSpeed,
                    windSpeedRaw,
                    windDirection,
                    sunriseHour,
                    sunsetHour
                };

                // Cache the result
                weatherCache[cacheKey] = weatherData;
                return weatherData;

            } catch (error) {
                console.error('Failed to fetch weather data:', error);
                const z = new Array(24).fill(0);
                return {
                    daylight: [0,0,0,0,0,0,0.1,0.4,0.7,0.9,1,1,1,1,1,1,0.9,0.5,0.1,0,0,0,0,0],
                    clouds: new Array(24).fill(0.3), rain: z, precipMm: z,
                    snow: null, snowCm: z, temperature: new Array(24).fill(0.5),
                    precipProbability: z, windSpeed: z, windSpeedRaw: z, windDirection: z,
                    sunriseHour: 6, sunsetHour: 18
                };
            }
        }

        // Find sunrise and sunset hours from daylight data
        function findSunriseSunset(daylightData) {
            let sunrise = 0, sunset = 23;
            for (let i = 0; i < daylightData.length; i++) {
                if (daylightData[i] > 0) {
                    sunrise = i;
                    break;
                }
            }
            for (let i = daylightData.length - 1; i >= 0; i--) {
                if (daylightData[i] > 0) {
                    sunset = i;
                    break;
                }
            }
            return { sunrise, sunset };
        }

        // Get display range: 2h before sunrise to 2h after sunset
        function getDisplayRange(data) {
            const { sunrise, sunset } = findSunriseSunset(data.daylight);
            const startHour = Math.max(0, sunrise - 2);
            const endHour = Math.min(23, sunset + 2);
            return { startHour, endHour };
        }

        function sliceWeatherData(data, startHour, endHour) {
            return data.slice(startHour, endHour + 1);
        }

        // Store display range for proper interpolation mapping
        let displayStartHour = 0;
        let displayEndHour = 23;

        // Store temperature display range (mean ± 10°C) for current location
        // These are normalized values (0-1 representing -25°C to +35°C)
        let tempDisplayMin = 0;  // Will be updated when location changes
        let tempDisplayMax = 1;  // Will be updated when location changes
        let tempRangeCity = null; // Track which city the temp range was calculated for
        let tempRangeBaseOffset = 0; // Track which day offset the temp range was calculated for

        // Map a normalized temperature (0-1) to display Y position fraction
        // Returns 0 at tempDisplayMin and 1 at tempDisplayMax
        function mapTempToDisplayRange(tempValue) {
            if (tempDisplayMax === tempDisplayMin) return 0.5;
            return (tempValue - tempDisplayMin) / (tempDisplayMax - tempDisplayMin);
        }

        // Calculate mean temperature across sample days for a location
        // baseOffset: the day offset to center the calculation around (0 for today, -30 for 30 days ago, etc.)
        async function calculateLocationTempRange(cityKey, baseOffset = 0) {
            let totalTemp = 0;
            let count = 0;

            // Fetch temperature data for baseOffset and baseOffset + maxFutureOffset (or just baseOffset for historical)
            const sampleDays = baseOffset >= 0
                ? [baseOffset, baseOffset + maxFutureOffset]
                : [baseOffset, baseOffset + 14]; // For historical, sample 2 weeks ahead from base

            for (const day of sampleDays) {
                try {
                    const dayData = await fetchWeatherData(cityKey, day);
                    if (dayData && dayData.temperature) {
                        // Sum all hourly temperatures
                        for (const temp of dayData.temperature) {
                            totalTemp += temp;
                            count++;
                        }
                    }
                } catch (e) {
                    // Skip days that fail to fetch
                    console.log(`Skipped day ${day} for temp range calculation`);
                }
            }

            if (count > 0) {
                const meanTemp = totalTemp / count;
                // Mean - 15°C to Mean + 22.5°C (asymmetric range, 50% larger)
                // In normalized space: 15°C = 15/60, 22.5°C = 22.5/60
                const rangeBelow = 15 / 60;
                const rangeAbove = 22.5 / 60;
                tempDisplayMin = Math.max(0, meanTemp - rangeBelow);
                tempDisplayMax = Math.min(1, meanTemp + rangeAbove);
                tempRangeBaseOffset = baseOffset;
                console.log(`Temp range for ${cityKey} (offset ${baseOffset}): mean=${((meanTemp * 60) - 25).toFixed(1)}°C, display range: ${((tempDisplayMin * 60) - 25).toFixed(1)}°C to ${((tempDisplayMax * 60) - 25).toFixed(1)}°C`);
            }
        }

        // Check if temp range needs recalculation based on day offset
        function needsTempRangeRecalc(dayOffset) {
            // Recalculate every 30 days when going back in time
            const currentBucket = Math.floor(dayOffset / 30) * 30;
            const rangeBucket = Math.floor(tempRangeBaseOffset / 30) * 30;
            return currentBucket !== rangeBucket;
        }

        async function updateWeatherData(cityKey, dayOffset = 0) {
            fullWeatherData = await fetchWeatherData(cityKey, dayOffset);
            const { startHour, endHour } = getDisplayRange(fullWeatherData);

            // Store display range for interpolation
            displayStartHour = startHour;
            displayEndHour = endHour;

            weatherData = {
                daylight: sliceWeatherData(fullWeatherData.daylight, startHour, endHour),
                clouds: sliceWeatherData(fullWeatherData.clouds, startHour, endHour),
                rain: sliceWeatherData(fullWeatherData.rain, startHour, endHour),
                precipMm: sliceWeatherData(fullWeatherData.precipMm, startHour, endHour),
                precipProbability: sliceWeatherData(fullWeatherData.precipProbability, startHour, endHour),
                snow: fullWeatherData.snow ? sliceWeatherData(fullWeatherData.snow, startHour, endHour) : null,
                snowCm: sliceWeatherData(fullWeatherData.snowCm, startHour, endHour),
                // Keep full 24-hour temperature data for proper Catmull-Rom interpolation at edges
                temperatureFull: fullWeatherData.temperature,
                temperature: sliceWeatherData(fullWeatherData.temperature, startHour, endHour),
                windSpeed: sliceWeatherData(fullWeatherData.windSpeed, startHour, endHour),
                windSpeedRaw: sliceWeatherData(fullWeatherData.windSpeedRaw, startHour, endHour),
                windDirection: sliceWeatherData(fullWeatherData.windDirection, startHour, endHour),
                sunriseHour: fullWeatherData.sunriseHour,
                sunsetHour: fullWeatherData.sunsetHour
            };
        }

        // Get day label for display
        function getDayLabel(dayOffset) {
            if (dayOffset === 0) return 'Today';
            if (dayOffset === 1) {
                const date = new Date();
                date.setDate(date.getDate() + 1);
                const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
                return `Tomorrow ${dayName}`;
            }
            if (dayOffset === -1) {
                const date = new Date();
                date.setDate(date.getDate() - 1);
                const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });
                return `Yesterday ${dayName}`;
            }

            const date = new Date();
            const currentYear = date.getFullYear();
            date.setDate(date.getDate() + dayOffset);
            // Include year if not current year
            const options = date.getFullYear() !== currentYear
                ? { weekday: 'long', month: 'short', day: 'numeric', year: 'numeric' }
                : { weekday: 'long', month: 'short', day: 'numeric' };
            return date.toLocaleDateString('en-US', options);
        }

        // Update the day label display
        function updateDayLabel() {
            document.getElementById('dayLabel').textContent = getDayLabel(currentDayOffset);
            // Past navigation is always enabled (unlimited history)
            document.getElementById('prevDay').disabled = false;
            document.getElementById('nextDay').disabled = currentDayOffset >= maxFutureOffset;
            // Also update city label
            const cityLabelEl = document.getElementById('cityLabel');
            if (cityLabelEl && cities[currentCity]) {
                cityLabelEl.textContent = cities[currentCity].name;
            }
        }

        // Loading state management
        let isLoading = false;

        function showLoading() {
            if (isLoading) return;
            isLoading = true;
            const overlay = document.getElementById('loadingOverlay');
            const loadingCurve = document.getElementById('loadingCurve');

            // Position the loading curve to match temperature curve area
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const skyRibbonEl = document.getElementById('skyRibbon');
            if (skyRibbonEl && wrapper) {
                const wrapperRect = wrapper.getBoundingClientRect();
                const skyRect = skyRibbonEl.getBoundingClientRect();
                const skyBottomInWrapper = skyRect.bottom - wrapperRect.top;
                loadingCurve.style.top = `${skyBottomInWrapper - 40}px`;
            } else {
                loadingCurve.style.top = '180px';
            }

            overlay.classList.add('visible');
        }

        function hideLoading() {
            isLoading = false;
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('visible');
        }

        // Check if weather data is already cached for a given city and day
        function isDataCached(cityKey, dayOffset) {
            const city = cities[cityKey];
            const dateStr = getDateForOffset(city, dayOffset);
            const cacheKey = `${cityKey}-${dateStr}`;
            return weatherCache[cacheKey] && weatherCache[cacheKey].precipMm && weatherCache[cacheKey].snowCm;
        }

        // Prefetch weather data in the background
        let prefetchInProgress = false;
        let prefetchedCity = null;
        let prefetchedPastBoundary = 0; // Track how far back we've prefetched

        // Prefetch future days (1 to maxFutureOffset)
        async function prefetchFutureDays(cityKey) {
            const batchSize = 3;
            for (let i = 1; i <= maxFutureOffset; i += batchSize) {
                if (prefetchedCity !== cityKey) break;
                const batch = [];
                for (let j = i; j < Math.min(i + batchSize, maxFutureOffset + 1); j++) {
                    if (!isDataCached(cityKey, j)) {
                        batch.push(fetchWeatherData(cityKey, j));
                    }
                }
                if (batch.length > 0) {
                    await Promise.all(batch);
                }
            }
        }

        // Prefetch past days in batches when user navigates backward
        async function prefetchPastDays(cityKey, fromOffset) {
            // Prefetch a batch of days before the current position
            const endOffset = fromOffset;
            const startOffset = fromOffset - historyBatchSize;

            const batch = [];
            for (let j = startOffset; j < endOffset; j++) {
                if (!isDataCached(cityKey, j)) {
                    batch.push(fetchWeatherData(cityKey, j));
                }
            }
            if (batch.length > 0) {
                await Promise.all(batch);
            }

            // Update boundary tracker
            if (startOffset < prefetchedPastBoundary) {
                prefetchedPastBoundary = startOffset;
            }
        }

        // Initial prefetch for future days
        async function prefetchRemainingDays(cityKey) {
            if (prefetchInProgress && prefetchedCity === cityKey) return;
            prefetchInProgress = true;
            prefetchedCity = cityKey;
            prefetchedPastBoundary = 0; // Reset past boundary for new city

            await prefetchFutureDays(cityKey);

            if (prefetchedCity === cityKey) {
                prefetchInProgress = false;
            }
        }

        // Refresh the current view
        // skipTempRangeRecalc: if true, keeps the current temperature bar range unchanged
        async function refreshView(skipTempRangeRecalc = false) {
            // Check if temp range needs recalculation
            const needsTempRecalc = !skipTempRangeRecalc && (tempRangeCity !== currentCity || needsTempRangeRecalc(currentDayOffset));
            // Only show loading if data isn't already cached
            const needsLoading = !isDataCached(currentCity, currentDayOffset) || needsTempRecalc;
            if (needsLoading) {
                showLoading();
            }
            try {
                // Recalculate temperature display range when city changes or every 30 days back
                if (needsTempRecalc) {
                    const baseOffset = Math.floor(currentDayOffset / 30) * 30;
                    await calculateLocationTempRange(currentCity, baseOffset);
                    tempRangeCity = currentCity;
                }
                await updateWeatherData(currentCity, currentDayOffset);
                updateDayLabel();
                draw();
            } finally {
                if (needsLoading) {
                    hideLoading();
                }
            }
        }

        // Smooth interpolation function
        function smoothstep(edge0, edge1, x) {
            const t = Math.max(0, Math.min(1, (x - edge0) / (edge1 - edge0)));
            return t * t * (3 - 2 * t);
        }

        // Basic interpolation for most data
        function interpolateData(data, t) {
            const len = data.length;
            const idx = t * (len - 1);
            const i0 = Math.floor(idx);
            const i1 = Math.min(i0 + 1, len - 1);
            const frac = idx - i0;
            return data[i0] + (data[i1] - data[i0]) * smoothstep(0, 1, frac);
        }

        // Catmull-Rom spline interpolation for smooth curves
        // For temperature data with useFullTemperatureData=true, uses full 24-hour data
        // to avoid edge flattening at display boundaries
        function interpolateDataSmooth(data, t, useFullTemperatureData = false) {
            // For temperature: use full 24-hour data with hour-based indexing
            if (useFullTemperatureData && weatherData.temperatureFull) {
                const fullData = weatherData.temperatureFull;

                // Map t (0-1 over display range) to actual hour in 24-hour data
                const displayHours = displayEndHour - displayStartHour;
                const hour = displayStartHour + t * displayHours;

                // Catmull-Rom needs 4 control points around the target hour
                // Use proper indexing into full 24-hour array
                const i1 = Math.min(23, Math.max(0, Math.floor(hour)));
                const i0 = Math.max(0, i1 - 1);
                const i2 = Math.min(23, i1 + 1);
                const i3 = Math.min(23, i1 + 2);
                const frac = hour - i1;

                // Get temperature values at these hours
                const p0 = fullData[i0];
                const p1 = fullData[i1];
                const p2 = fullData[i2];
                const p3 = fullData[i3];

                // Catmull-Rom spline formula with tension=0.5 (standard)
                const tt = frac * frac;
                const ttt = tt * frac;

                return 0.5 * (
                    (2 * p1) +
                    (-p0 + p2) * frac +
                    (2 * p0 - 5 * p1 + 4 * p2 - p3) * tt +
                    (-p0 + 3 * p1 - 3 * p2 + p3) * ttt
                );
            }

            // For other data: use array-index-based interpolation
            const len = data.length;
            if (len < 2) return data[0] || 0;

            const idx = t * (len - 1);
            const i1 = Math.min(len - 1, Math.max(0, Math.floor(idx)));
            const i0 = Math.max(0, i1 - 1);
            const i2 = Math.min(len - 1, i1 + 1);
            const i3 = Math.min(len - 1, i1 + 2);
            const frac = idx - i1;

            const p0 = data[i0];
            const p1 = data[i1];
            const p2 = data[i2];
            const p3 = data[i3];

            // Catmull-Rom spline formula
            const tt = frac * frac;
            const ttt = tt * frac;

            return 0.5 * (
                (2 * p1) +
                (-p0 + p2) * frac +
                (2 * p0 - 5 * p1 + 4 * p2 - p3) * tt +
                (-p0 + 3 * p1 - 3 * p2 + p3) * ttt
            );
        }

        // Color interpolation
        function lerpColor(color1, color2, t) {
            return {
                r: color1.r + (color2.r - color1.r) * t,
                g: color1.g + (color2.g - color1.g) * t,
                b: color1.b + (color2.b - color1.b) * t
            };
        }

        function colorToString(c, alpha = 1) {
            return `rgba(${Math.round(c.r)}, ${Math.round(c.g)}, ${Math.round(c.b)}, ${alpha})`;
        }

        // Noise function for organic feel
        function noise(x, y, seed = 0) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + seed) * 43758.5453;
            return n - Math.floor(n);
        }

        // Calculate maximum rain height needed for the visualization
        function calculateMaxRainHeight() {
            let maxRain = 0;
            for (let i = 0; i < weatherData.rain.length; i++) {
                if (weatherData.rain[i] > maxRain) {
                    maxRain = weatherData.rain[i];
                }
            }
            return maxRain;
        }

        // Calculate maximum snow intensity
        function calculateMaxSnow() {
            if (!weatherData.snow) return 0;
            let maxSnow = 0;
            for (let i = 0; i < weatherData.snow.length; i++) {
                if (weatherData.snow[i] > maxSnow) {
                    maxSnow = weatherData.snow[i];
                }
            }
            return maxSnow;
        }

        // Sky colors: [top, bottom] for each phase
        const skyPalette = {
            black: {r:3,g:3,b:8}, night: [{r:12,g:18,b:38},{r:20,g:30,b:55}],
            twilight: [{r:55,g:45,b:85},{r:85,g:65,b:105}], dawn: [{r:255,g:130,b:90},{r:255,g:175,b:130}],
            day: [{r:85,g:170,b:235},{r:150,g:205,b:250}], noon: [{r:120,g:195,b:255},{r:170,g:220,b:255}]
        };

        function getSkyColor(dayValue, cloudValue = 1) {
            const {black, night, twilight, dawn, day, noon} = skyPalette;
            const s = (a,b,v) => smoothstep(a,b,dayValue);
            let top = lerpColor(night[0], twilight[0], s(0,0.2));
            let bottom = lerpColor(night[1], twilight[1], s(0,0.2));
            top = lerpColor(top, dawn[0], s(0.1,0.4)); bottom = lerpColor(bottom, dawn[1], s(0.1,0.4));
            top = lerpColor(top, day[0], s(0.3,0.65)); bottom = lerpColor(bottom, day[1], s(0.3,0.65));
            top = lerpColor(top, noon[0], s(0.55,0.9)); bottom = lerpColor(bottom, noon[1], s(0.55,0.9));
            const blackBlend = (1 - smoothstep(0,0.35,dayValue)) * (1 - smoothstep(0,0.08,cloudValue));
            if (blackBlend > 0) { top = lerpColor(top, black, blackBlend); bottom = lerpColor(bottom, black, blackBlend); }
            return { top, bottom };
        }

        // Unified Sky Ribbon with day/night cycle, clouds, and rain
        // Shows only the bottom three-quarters (omits upper star region at night)
        function drawSkyRibbon() {
            const canvas = document.getElementById('skyRibbon');
            const wrapper = canvas.parentElement;

            // Calculate dimensions
            const fullBaseHeight = 240; // Full height for the sky/cloud portion (doubled)
            const skyExtensionHeight = 36; // Sky gradient fade distance (reduced by 40%)
            const precipExtensionHeight = 200; // Rain/snow extends down over page background
            const fullTotalHeight = fullBaseHeight + precipExtensionHeight;

            // Crop top portion of the sky (removes cloud puffs, shows only lower sky gradient)
            const cropAmount = fullBaseHeight * 0.55;
            const visibleHeight = fullTotalHeight - cropAmount;
            const maxRain = calculateMaxRainHeight();

            // Set wrapper and canvas height to cropped size
            wrapper.style.height = visibleHeight + 'px';

            const ctx = canvas.getContext('2d');
            const width = wrapper.offsetWidth;
            canvas.width = width * 2;
            canvas.height = visibleHeight * 2;
            ctx.scale(2, 2);

            // We'll draw as if starting from cropAmount, so adjust all Y coordinates
            // by translating the context up
            ctx.translate(0, -cropAmount);

            const height = fullTotalHeight;
            const skyHeight = fullBaseHeight;

            // Cloud base position - clouds start at top and extend down
            const cloudBottomY = skyHeight * 0.5; // Bottom edge of cloud layer
            // Sky gradient fades out within the shorter sky extension area
            const skyFadeEndY = fullBaseHeight + skyExtensionHeight;

            // First, draw the sky color that extends DOWN from the cloud bottom
            // Sky fades out within skyFadeEndY, not the full height
            for (let x = 0; x < width; x++) {
                const t = x / width;
                const dayValue = interpolateData(weatherData.daylight, t);
                const cloudValue = interpolateData(weatherData.clouds, t);
                const skyColors = getSkyColor(dayValue, cloudValue);

                // Calculate sky color blended with grey based on cloud coverage
                // Use cosine interpolation for smooth brightness transitions
                const greyColor = { r: 180, g: 185, b: 195 };
                const cloudBlend = 0.5 * (1 - Math.cos(cloudValue * Math.PI));
                const skyColor = lerpColor(skyColors.bottom, greyColor, cloudBlend);

                // Create gradient from cloud bottom down, fading to transparent with cosine decay
                const gradient = ctx.createLinearGradient(x, cloudBottomY, x, skyFadeEndY);
                const numStops = 10;
                for (let i = 0; i <= numStops; i++) {
                    const t = i / numStops;
                    // Cosine decay: starts at 1, smoothly decays to 0
                    const alpha = 0.5 * (1 + Math.cos(t * Math.PI));
                    gradient.addColorStop(t, colorToString(skyColor, alpha));
                }

                ctx.fillStyle = gradient;
                ctx.fillRect(x, cloudBottomY, 1.5, skyFadeEndY - cloudBottomY);
            }

            // Draw cloud layer at the TOP of the ribbon
            for (let x = 0; x < width; x++) {
                const t = x / width;
                const cloudValue = interpolateData(weatherData.clouds, t);
                const rainValue = interpolateData(weatherData.rain, t);
                const dayValue = interpolateData(weatherData.daylight, t);

                // Use cosine interpolation for smooth cloud coverage transitions
                const cloudSmooth = 0.5 * (1 - Math.cos(cloudValue * Math.PI));

                // Calculate cloud color based on time of day using smooth transitions
                // Night clouds (dark), twilight clouds (medium), day clouds (bright)
                const nightGray = 60 - cloudSmooth * 20 - rainValue * 20;
                const dayGray = 230 - cloudSmooth * 30 - rainValue * 40;
                // Smooth transition using smoothstep for continuous blending
                const dayBlend = smoothstep(0.15, 0.55, dayValue);
                const baseGray = nightGray + (dayGray - nightGray) * dayBlend;

                // Add color tint for dawn/dusk using smooth gaussian-like curve
                let r = baseGray, g = baseGray, b = baseGray;
                // Peak tint at dayValue=0.35, smooth falloff in both directions
                const tintCenter = 0.35;
                const tintWidth = 0.2;
                const tintDist = Math.abs(dayValue - tintCenter) / tintWidth;
                const tintStrength = Math.max(0, 1 - tintDist * tintDist); // Smooth quadratic falloff
                r = Math.min(255, baseGray + 40 * tintStrength);
                g = Math.min(255, baseGray + 15 * tintStrength);
                b = Math.max(0, baseGray - 10 * tintStrength);

                // Fill the top area with cloud color (only visible when there are clouds)
                // Use cosine-smoothed alpha for gradual transitions
                const alpha = cloudSmooth;

                // Skip drawing if no clouds (fully transparent)
                if (alpha < 0.01) continue;

                const gradient = ctx.createLinearGradient(x, 0, x, cloudBottomY + 20);
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b + 5}, ${alpha})`);
                gradient.addColorStop(0.6, `rgba(${r}, ${g}, ${b + 5}, ${alpha * 0.95})`);
                gradient.addColorStop(0.85, `rgba(${r - 5}, ${g - 3}, ${b}, ${alpha * 0.7})`);
                gradient.addColorStop(1, `rgba(${r - 10}, ${g - 5}, ${b - 5}, 0)`);

                ctx.fillStyle = gradient;
                ctx.fillRect(x, 0, 1.5, cloudBottomY + 20);

                // Add cloud texture/puffs at the bottom edge of the cloud layer
                const puffFreq = 0.02;
                for (let i = 0; i < 6; i++) {
                    const puffX = x + noise(x * puffFreq, i) * 15;
                    const puffY = cloudBottomY - 10 + noise(x, i) * 25;
                    const puffSize = (12 + noise(x, i * 2) * 20) * cloudSmooth;

                    if (puffSize > 3) {
                        const puffAlpha = Math.min(0.9, cloudSmooth * 0.8);
                        const puffGradient = ctx.createRadialGradient(puffX, puffY, 0, puffX, puffY, puffSize);
                        puffGradient.addColorStop(0, `rgba(${r + 10}, ${g + 10}, ${b + 15}, ${puffAlpha})`);
                        puffGradient.addColorStop(0.5, `rgba(${r}, ${g + 3}, ${b + 8}, ${puffAlpha * 0.7})`);
                        puffGradient.addColorStop(1, `rgba(${r - 10}, ${g - 5}, ${b}, 0)`);

                        ctx.fillStyle = puffGradient;
                        ctx.beginPath();
                        ctx.arc(puffX, puffY, puffSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw night sky darkening overlay - limited to sky portion (skyFadeEndY)
            for (let x = 0; x < width; x++) {
                const t = x / width;
                const dayValue = interpolateData(weatherData.daylight, t);
                const cloudValue = interpolateData(weatherData.clouds, t);

                // Night darkness intensity - stronger at night, fades during twilight
                const nightness = 1 - smoothstep(0.0, 0.4, dayValue);

                if (nightness > 0.01) {
                    // Dark blue-black overlay for night sky
                    // Use cosine interpolation for smooth cloud-based darkness transitions
                    // More clouds = darker (blocks light pollution), fewer clouds = slightly lighter
                    const cloudSmooth = 0.5 * (1 - Math.cos(cloudValue * Math.PI));
                    // Darkness ranges from 0.6 (clear) to 0.95 (overcast) smoothly
                    const darkness = nightness * (0.6 + cloudSmooth * 0.35);

                    // Create gradient from top to skyFadeEndY (sky portion only, not precipitation area)
                    const gradient = ctx.createLinearGradient(x, cropAmount, x, skyFadeEndY);
                    gradient.addColorStop(0, `rgba(5, 8, 20, ${darkness})`);
                    gradient.addColorStop(0.5, `rgba(8, 12, 28, ${darkness * 0.85})`);
                    gradient.addColorStop(0.85, `rgba(10, 15, 35, ${darkness * 0.5})`);
                    gradient.addColorStop(1, `rgba(12, 18, 40, 0)`);

                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, cropAmount, 1.5, skyFadeEndY - cropAmount);
                }
            }

            // Draw stars at night - pre-generated random positions for natural distribution
            const starCount = 400;
            const skyAreaHeight = skyFadeEndY - cropAmount;
            // Star color palette: mostly white, some with subtle tints
            const starColors = [
                {r:255,g:255,b:255}, {r:255,g:255,b:255}, {r:255,g:255,b:255}, {r:255,g:255,b:255}, // white (common)
                {r:255,g:240,b:220}, {r:255,g:235,b:210}, // warm white/yellow
                {r:220,g:235,b:255}, {r:200,g:220,b:255}, // cool white/blue
                {r:255,g:220,b:210}, {r:255,g:200,b:180}  // warm/reddish
            ];
            for (let i = 0; i < starCount; i++) {
                const starX = noise(i * 7.3, 0) * width;
                const starY = cropAmount + noise(i * 13.7, 1) * skyAreaHeight;

                const t = starX / width;
                const dayValue = interpolateData(weatherData.daylight, t);
                const cloudValue = interpolateData(weatherData.clouds, t);
                const starVisibility = 1 - smoothstep(0.0, 0.35, dayValue);
                const cloudFade = 1 - smoothstep(0.3, 0.7, cloudValue);
                const combinedVisibility = starVisibility * cloudFade;

                if (combinedVisibility > 0.01) {
                    const size = 0.4 + noise(i, 2) * 1.0;
                    const brightness = 0.3 + noise(i, 3) * 0.7;
                    const color = starColors[Math.floor(noise(i, 4) * starColors.length)];
                    ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${combinedVisibility * brightness})`;
                    ctx.beginPath();
                    ctx.arc(starX, starY, size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw rain falling from clouds (only where there's rain)
            // Rain extends over page background - realistic streaks with depth layers
            if (maxRain > 0) {
                // Multiple depth layers for parallax effect - closer drops are larger and more opaque
                const dropLayers = [
                    { count: 500, size: 0.8, opacity: 0.25, lengthMult: 0.7 },   // Far background
                    { count: 400, size: 1.2, opacity: 0.4, lengthMult: 0.85 },   // Mid background
                    { count: 300, size: 1.8, opacity: 0.55, lengthMult: 1.0 },   // Mid foreground
                    { count: 200, size: 2.5, opacity: 0.7, lengthMult: 1.15 }    // Close foreground
                ];

                // Slight angle for wind-driven rain (about 10-12 degrees from vertical)
                const rainAngle = 0.18; // x offset per y unit

                dropLayers.forEach((layer, layerIdx) => {
                    for (let i = 0; i < layer.count; i++) {
                        const baseX = (noise(i, layerIdx) * width);
                        const t = baseX / width;
                        const rainValue = interpolateData(weatherData.rain, t);

                        // Skip rain if there's snow at this position (show only snow)
                        const snowValue = weatherData.snow ? interpolateData(weatherData.snow, t) : 0;
                        if (snowValue > 0.05) continue;

                        if (rainValue > 0.02 && noise(i * 2, layerIdx) < rainValue) {
                            // Slight horizontal spread for natural variation
                            const x = baseX + noise(i, layerIdx + 10) * 20 - 10;

                            // Rain falls from clouds down through extended precipitation area
                            const rainStartY = cropAmount + 20;
                            const rainEndY = skyHeight + rainValue * precipExtensionHeight;
                            const y = rainStartY + noise(i, layerIdx + 20) * (rainEndY - rainStartY);

                            // Drop length varies with rain intensity and layer depth
                            const baseLength = 8 + rainValue * 18;
                            const dropLength = baseLength * layer.lengthMult;

                            if (dropLength > 4) {
                                // Calculate end position with slight angle
                                const endX = x + dropLength * rainAngle;
                                const endY = y + dropLength;

                                // Gradient rain streak - brighter at top, fading at bottom
                                const gradient = ctx.createLinearGradient(x, y, endX, endY);
                                const r = 160, g = 195, b = 255;
                                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${layer.opacity * 0.3})`);
                                gradient.addColorStop(0.2, `rgba(${r}, ${g}, ${b}, ${layer.opacity})`);
                                gradient.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, ${layer.opacity * 0.6})`);
                                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);

                                ctx.strokeStyle = gradient;
                                ctx.lineWidth = layer.size;
                                ctx.lineCap = 'round';
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(endX, endY);
                                ctx.stroke();
                            }
                        }
                    }
                });

            }

            // Draw snow falling from clouds (only where there's snow)
            // Snow extends over page background - soft glowing flakes with depth
            const maxSnow = calculateMaxSnow();
            if (maxSnow > 0) {
                // Multiple depth layers for parallax - closer flakes larger and brighter
                const snowLayers = [
                    { count: 400, size: 1.0, opacity: 0.3, blur: 0.5 },   // Far background - tiny, dim
                    { count: 350, size: 1.8, opacity: 0.5, blur: 0.3 },   // Mid background
                    { count: 300, size: 2.8, opacity: 0.7, blur: 0.2 },   // Mid foreground
                    { count: 200, size: 4.0, opacity: 0.9, blur: 0 }      // Close foreground - large, bright
                ];

                snowLayers.forEach((layer, layerIdx) => {
                    for (let i = 0; i < layer.count; i++) {
                        const baseX = noise(i, layerIdx + 50) * width;
                        const t = baseX / width;
                        const snowValue = interpolateData(weatherData.snow, t);

                        if (snowValue > 0.05 && noise(i * 3, layerIdx + 60) < snowValue) {
                            // Snowflakes drift sideways with gentle wave pattern
                            const driftPhase = noise(i, layerIdx + 70) * Math.PI * 2;
                            const driftAmount = 12 + noise(i * 2, layerIdx) * 10;
                            const drift = Math.sin(driftPhase) * driftAmount;
                            const x = baseX + drift;

                            // Snow falls from clouds down through extended precipitation area
                            const snowStartY = cropAmount + 20;
                            const snowEndY = skyHeight + snowValue * precipExtensionHeight;
                            const y = snowStartY + noise(i, layerIdx + 80) * (snowEndY - snowStartY);

                            // Size varies slightly per flake
                            const sizeVariation = 0.7 + noise(i, layerIdx + 90) * 0.6;
                            const flakeSize = layer.size * sizeVariation;

                            // Draw snowflake with soft radial gradient for glow effect
                            const gradient = ctx.createRadialGradient(x, y, 0, x, y, flakeSize);
                            gradient.addColorStop(0, `rgba(255, 255, 255, ${layer.opacity})`);
                            gradient.addColorStop(0.4, `rgba(240, 248, 255, ${layer.opacity * 0.7})`);
                            gradient.addColorStop(0.8, `rgba(220, 235, 255, ${layer.opacity * 0.3})`);
                            gradient.addColorStop(1, `rgba(200, 220, 255, 0)`);

                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(x, y, flakeSize * 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
            }

        }

        // Temperature color mapping (global for tooltip use)
        // Temperature colors: refined palette
        // white (freezing) → blue (cold) → yellow (mild) → orange (warm) → red (hot) → dark red (extreme)
        const tempColors = {
            white: { r: 230, g: 240, b: 255 },      // <=0°C - icy white
            blue: { r: 80, g: 160, b: 230 },        // 10°C - cool blue
            yellow: { r: 255, g: 220, b: 80 },      // 20°C - warm golden
            orange: { r: 255, g: 145, b: 70 },      // 30°C - warm orange
            red: { r: 235, g: 70, b: 55 },          // 40°C - vivid red
            darkRed: { r: 160, g: 30, b: 30 }       // >40°C - dark red
        };
        // Temperature thresholds (normalized: (temp + 25) / 60)
        const tempThresholds = {
            minusTen: (-10 + 25) / 60,  // -10°C = 0.25
            zero: (0 + 25) / 60,        // 0°C = 0.417
            ten: (10 + 25) / 60,        // 10°C = 0.583
            twenty: (20 + 25) / 60,     // 20°C = 0.75
            thirty: (30 + 25) / 60,     // 30°C = 0.917
            forty: (40 + 25) / 60       // 40°C = 1.083
        };

        function getTempColor(tempValue) {
            const { white, blue, yellow, orange, red, darkRed } = tempColors;
            const { minusTen, zero, ten, twenty, thirty, forty } = tempThresholds;

            if (tempValue < zero) return white;  // <=0°C: solid white (dashed handled separately)
            if (tempValue < ten) return lerpColor(white, blue, (tempValue - zero) / (ten - zero));
            if (tempValue < twenty) return lerpColor(blue, yellow, (tempValue - ten) / (twenty - ten));
            if (tempValue < thirty) return lerpColor(yellow, orange, (tempValue - twenty) / (thirty - twenty));
            if (tempValue < forty) return lerpColor(orange, red, (tempValue - thirty) / (forty - thirty));
            return darkRed;  // >40°C: solid dark red
        }

        // Check if temperature should be drawn dashed (below 0°C)
        function isTempDashed(tempValue) {
            return tempValue < tempThresholds.zero;
        }

        // Get dash pattern based on temperature (longer gaps as it gets colder)
        // Returns [dashLength, gapLength] or null for continuous line
        function getTempDashPattern(tempValue) {
            const { zero, minusTen } = tempThresholds;
            const minusOne = (-1 + 25) / 60;

            if (tempValue >= minusOne) return null; // Continuous at 0°C to -1°C

            // Calculate how far below -1°C (0 at -1°C, 1 at -10°C or below)
            const coldness = Math.min(1, (minusOne - tempValue) / (minusOne - minusTen));

            // Dash length stays constant, gap increases with coldness
            const dashLength = 10;
            const minGap = 4;   // Gap just below -1°C
            const maxGap = 10;  // Gap at -10°C or below
            const gapLength = minGap + coldness * (maxGap - minGap);

            return [dashLength, gapLength];
        }

        function getDaylightBrightness(dayValue) {
            return 0.05 + 0.95 * smoothstep(0.1, 0.65, dayValue);
        }

        // Temperature Curve on page background
        function drawTemperatureCurve() {
            const canvas = document.getElementById('tempCurveCanvas');
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const skyRibbonEl = document.getElementById('skyRibbon');
            const ctx = canvas.getContext('2d');

            // Get wrapper and sky ribbon dimensions for relative positioning
            const wrapperRect = wrapper.getBoundingClientRect();
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const width = window.innerWidth;
            const height = wrapperRect.height || window.innerHeight * 0.6;

            // Calculate sky ribbon position relative to wrapper
            const skyBottomInWrapper = (skyRect.bottom - wrapperRect.top);

            // Set canvas to wrapper size
            canvas.width = width * 2;
            canvas.height = height * 2;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(2, 2);

            // Draw the temperature curve with gradient fill
            const curveHeight = Math.min(height * 0.396, 216); // Curve height, capped (50% taller)
            // The reference line top is at curveBottom - (maxTempNorm * curveHeight * 0.8)
            // where maxTempNorm = (45 + 25) / 60 = 1.167 (clamped to ~1)
            // So reference line top offset from curveBottom is about curveHeight * 0.8
            // We want that point to be at skyBottomInWrapper, then shift up 200px
            const curveBottom = skyBottomInWrapper + curveHeight * 0.8 - 160;
            const curveTop = curveBottom - curveHeight;

            // Get sky ribbon bounds relative to the canvas (which starts at 0)
            // skyRect is in screen coordinates, so subtract the wrapper's left position
            const ribbonLeft = skyRect.left - wrapperRect.left;
            const ribbonRight = skyRect.right - wrapperRect.left;
            const ribbonWidth = ribbonRight - ribbonLeft;

            // Pre-calculate curve data for all x positions
            const startX = Math.floor(ribbonLeft), endX = Math.ceil(ribbonRight);
            const curveData = [];
            for (let x = startX; x < endX; x++) {
                const t = (x - ribbonLeft) / ribbonWidth;
                const tempValue = interpolateDataSmooth(weatherData.temperature, t, true);
                const dayValue = interpolateData(weatherData.daylight, t);
                const brightness = getDaylightBrightness(dayValue);
                const color = getTempColor(tempValue);
                const y = curveBottom - (mapTempToDisplayRange(tempValue) * curveHeight * 0.8);
                curveData.push({ x, y, color, brightness, tempValue });
            }

            // Draw filled area under curve (continuous shading for all temps)
            curveData.forEach(d => {
                const gradient = ctx.createLinearGradient(d.x, d.y, d.x, curveBottom);
                for (let i = 0; i <= 8; i++) {
                    const t = i / 8;
                    gradient.addColorStop(t, colorToString(d.color, 0.35 * d.brightness * Math.pow(1 - t, 2.5)));
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(d.x, d.y, 1.5, curveBottom - d.y);
            });

            // Draw curve layers (glow + line + highlight) in single pass per layer
            const layers = [
                { width: 8, alpha: 0.08 },
                { width: 4, alpha: 0.18 },
                { width: 2, alpha: 0.85 },
                { width: 0.8, alpha: 0.5, highlight: true }
            ];
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Draw all curve segments with variable dash pattern based on temperature
            // For temps >= 0°C: continuous line
            // For temps < 0°C: dashed with gaps increasing as temperature decreases
            layers.forEach(layer => {
                // Track dash state across the curve for smooth dashing
                let dashOffset = 0;

                for (let i = 0; i < curveData.length - 1; i++) {
                    const d1 = curveData[i], d2 = curveData[i + 1];
                    const c = layer.highlight
                        ? { r: Math.min(255, d1.color.r + 40), g: Math.min(255, d1.color.g + 40), b: Math.min(255, d1.color.b + 40) }
                        : d1.color;

                    // Apply brightness to both alpha and line width (thinner at night)
                    const widthScale = 0.4 + 0.6 * d1.brightness;
                    ctx.lineWidth = layer.width * widthScale;
                    ctx.strokeStyle = colorToString(c, layer.alpha * d1.brightness);

                    // Get dash pattern based on temperature
                    const dashPattern = getTempDashPattern(d1.tempValue);

                    if (dashPattern) {
                        // Calculate segment length for dash offset tracking
                        const segLength = Math.sqrt(Math.pow(d2.x - d1.x, 2) + Math.pow(d2.y - d1.y, 2));
                        const [dashLen, gapLen] = dashPattern;
                        const cycleLen = dashLen + gapLen;

                        // Determine if we're in a dash or gap based on offset
                        const posInCycle = dashOffset % cycleLen;
                        const inDash = posInCycle < dashLen;

                        if (inDash) {
                            ctx.setLineDash([]);
                            ctx.beginPath();
                            ctx.moveTo(d1.x, d1.y);
                            ctx.lineTo(d2.x, d2.y);
                            ctx.stroke();
                        }
                        // Update dash offset for next segment
                        dashOffset += segLength;
                    } else {
                        // Continuous line for temps >= 0°C
                        ctx.setLineDash([]);
                        ctx.beginPath();
                        ctx.moveTo(d1.x, d1.y);
                        ctx.lineTo(d2.x, d2.y);
                        ctx.stroke();
                        // Reset dash offset when returning to continuous
                        dashOffset = 0;
                    }
                }
            });

            ctx.setLineDash([]); // Reset dash pattern

            // Draw temperature reference line at noon
            // Shows the limited range (tempDisplayMin to tempDisplayMax) using the same color coding
            // Position reference line at noon (center of the ribbon, same vertical range as curve)
            const refLineX = (ribbonLeft + ribbonRight) / 2;
            // Reference line spans full display height (0 to 1 in mapped space)
            const refLineTop = curveBottom - (1.0 * curveHeight * 0.8);  // Top of display range
            const refLineBottom = curveBottom - (0.0 * curveHeight * 0.8);  // Bottom of display range

            // Draw the reference line pixel by pixel with temperature colors (very thin, dimmed)
            for (let y = refLineTop; y < refLineBottom; y++) {
                // Map y position to temperature (top = hot, bottom = cold)
                const t = (y - refLineTop) / (refLineBottom - refLineTop);
                // Map from display position (0-1) back to actual temperature
                const tempNorm = tempDisplayMax - t * (tempDisplayMax - tempDisplayMin);
                const color = getTempColor(tempNorm);

                ctx.fillStyle = colorToString(color, 0.3);
                ctx.fillRect(refLineX, y, 1, 1.5);
            }

            // Add tick marks at -10°C, 0°C and 40°C if within display range
            const tickTemps = [-10, 0, 40];
            tickTemps.forEach(tempC => {
                const tempNorm = (tempC + 25) / 60;
                if (tempNorm >= tempDisplayMin && tempNorm <= tempDisplayMax) {
                    const tickY = curveBottom - (mapTempToDisplayRange(tempNorm) * curveHeight * 0.8);
                    const tickColor = getTempColor(tempNorm);
                    ctx.fillStyle = colorToString(tickColor, 0.4);
                    ctx.fillRect(refLineX - 2, tickY, 4, 1);
                }
            });

            // Draw current time marker (only for today's view)
            // Positioned above the sky ribbon
            if (currentDayOffset === 0) {
                const city = cities[currentCity];
                const now = new Date();
                // Get current hour and minute in the city's timezone
                const timeStr = now.toLocaleTimeString('en-US', {
                    timeZone: city.timezone,
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit'
                });
                const [hours, minutes] = timeStr.split(':').map(Number);
                const currentHour = hours + minutes / 60;

                // Map current time to position within the display range (not full 24h)
                // displayStartHour and displayEndHour define the visible range
                const displayHours = displayEndHour - displayStartHour;
                const currentTimeT = (currentHour - displayStartHour) / displayHours;

                // Only draw marker if current time is within the displayed range
                if (currentTimeT >= 0 && currentTimeT <= 1) {
                    // Calculate X position within the ribbon bounds
                    const markerX = ribbonLeft + currentTimeT * ribbonWidth;

                    // Get the actual position of the sky ribbon element relative to wrapper
                    const skyTopInWrapper = (skyRect.top - wrapperRect.top) - 2;

                    // Draw a refined triangle marker with soft glow
                    // Outer glow
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                    ctx.beginPath();
                    ctx.moveTo(markerX, skyTopInWrapper + 1);
                    ctx.lineTo(markerX - 7, skyTopInWrapper - 10);
                    ctx.lineTo(markerX + 7, skyTopInWrapper - 10);
                    ctx.closePath();
                    ctx.fill();

                    // Inner triangle
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                    ctx.beginPath();
                    ctx.moveTo(markerX, skyTopInWrapper);
                    ctx.lineTo(markerX - 4, skyTopInWrapper - 7);
                    ctx.lineTo(markerX + 4, skyTopInWrapper - 7);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        // Wind animation state
        let windAnimationId = null;
        let windStreaks = [];
        const WIND_THRESHOLD = 0.2; // Only show wind when > 20% of max (16+ km/h)

        // Check if there's substantial wind to animate
        function hasSubstantialWind() {
            if (!weatherData.windSpeed) return false;
            return weatherData.windSpeed.some(w => w >= WIND_THRESHOLD);
        }

        // Get wind display boundaries in screen coordinates
        function getWindBounds() {
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const skyRibbonEl = document.getElementById('skyRibbon');
            const wrapperRect = wrapper.getBoundingClientRect();
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const height = wrapperRect.height || window.innerHeight * 0.6;

            // Calculate sky ribbon position relative to wrapper
            const skyBottomInWrapper = (skyRect.bottom - wrapperRect.top);

            // Match the temperature curve positioning (shifted up 200px)
            const curveHeight = Math.min(height * 0.396, 216);
            const curveBottom = skyBottomInWrapper + curveHeight * 0.8 - 160;
            const curveTop = curveBottom - curveHeight;

            // Wind display area spans the full temperature curve height
            // Use the same mapping as the temperature curve
            const windTopY = curveBottom - (1.0 * curveHeight * 0.8);  // Top of curve
            const windBottomY = curveBottom - (0.0 * curveHeight * 0.8);  // Bottom of curve

            // Get sky ribbon bounds relative to the canvas (which starts at 0)
            const ribbonLeft = skyRect.left - wrapperRect.left;
            const ribbonRight = skyRect.right - wrapperRect.left;

            return {
                left: ribbonLeft,
                right: ribbonRight,
                top: windTopY,
                bottom: windBottomY,
                width: ribbonRight - ribbonLeft,
                height: windBottomY - windTopY
            };
        }

        // Initialize wind streaks based on weather data
        // Streaks are positioned at fixed X locations (corresponding to hours)
        function initWindStreaks() {
            windStreaks = [];
            if (!hasSubstantialWind()) return;

            const bounds = getWindBounds();

            // Create streaks at fixed horizontal positions across the ribbon
            // Multiple streaks per column for density
            const columnsCount = 40; // Number of x positions (halved for less density)
            const streaksPerColumn = 2; // Reduced from 3

            for (let col = 0; col < columnsCount; col++) {
                const xPos = (col / columnsCount) * bounds.width;
                for (let s = 0; s < streaksPerColumn; s++) {
                    windStreaks.push({
                        x: xPos,
                        y: Math.random() * bounds.height,
                        baseY: Math.random() * bounds.height, // Fixed base Y position
                        length: 30 + Math.random() * 50,
                        phase: Math.random() * Math.PI * 2, // Animation phase offset
                        speed: 0.5 + Math.random() * 1.5, // Animation speed
                        opacity: 0.15 + Math.random() * 0.25,
                        seed: Math.random() * 1000
                    });
                }
            }
        }

        // Draw animated wind streaks
        function drawWindAnimation(timestamp) {
            const canvas = document.getElementById('windCanvas');
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const ctx = canvas.getContext('2d');

            // Get wrapper dimensions for relative positioning
            const wrapperRect = wrapper.getBoundingClientRect();
            const width = window.innerWidth;
            const height = wrapperRect.height || window.innerHeight * 0.6;

            // Set canvas to wrapper size with retina support
            canvas.width = width * 2;
            canvas.height = height * 2;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(2, 2);

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            if (!hasSubstantialWind() || windStreaks.length === 0) {
                windAnimationId = requestAnimationFrame(drawWindAnimation);
                return;
            }

            const bounds = getWindBounds();
            const time = timestamp / 1000;

            // Temperature curve parameters (same as in drawTemperatureCurve)
            // Get sky ribbon position for proper curve placement
            const skyRibbonEl = document.getElementById('skyRibbon');
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const skyBottomInWrapper = (skyRect.bottom - wrapperRect.top);
            const curveHeight = Math.min(height * 0.396, 216);
            const curveBottom = skyBottomInWrapper + curveHeight * 0.8 - 160;
            const curveTop = curveBottom - curveHeight;

            // Horizontal orientation
            const angle = 0;

            // Small vertical offset above the temperature curve (negative = above)
            const verticalOffset = -5;

            // Draw each wind streak
            windStreaks.forEach(streak => {
                // Get wind data at streak's fixed x position (normalized 0-1 across ribbon width)
                const t = streak.x / bounds.width;
                const tClamped = Math.max(0, Math.min(1, t));
                const windSpeed = interpolateData(weatherData.windSpeed, tClamped);
                const dayValue = interpolateData(weatherData.daylight, tClamped);
                const tempValue = interpolateData(weatherData.temperature, tClamped);

                // Only draw if wind is substantial at this position
                if (windSpeed < WIND_THRESHOLD) return;

                // Calculate streak properties based on wind
                const windIntensity = (windSpeed - WIND_THRESHOLD) / (1 - WIND_THRESHOLD);
                const streakLength = streak.length * (0.5 + windIntensity);

                // Animated shimmer effect - opacity pulses over time
                const shimmer = 0.5 + 0.5 * Math.sin(time * streak.speed + streak.phase);

                // Calculate screen coordinates
                // X is fixed at the streak's horizontal position
                const screenX = bounds.left + streak.x;
                // Y is at the temperature curve position - offset (above) - streak's baseY offset
                const tempY = curveBottom - (mapTempToDisplayRange(tempValue) * curveHeight * 0.8);
                const screenY = tempY + verticalOffset - streak.baseY * 0.3; // baseY provides variation above
                const endX = screenX + streakLength;
                const endY = screenY + angle * streakLength;

                // Calculate streak color - white for visibility
                const brightness = 255;
                // Fade based on distance from temperature curve
                const distFromCurve = streak.baseY * 0.3;
                const distanceFade = Math.max(0, 1 - distFromCurve / 30);
                const alpha = streak.opacity * windIntensity * (0.6 + dayValue * 0.4) * 2.5 * distanceFade * shimmer;

                // Skip if too faint
                if (alpha < 0.02) return;

                // Draw the wind streak as a tapered line
                const gradient = ctx.createLinearGradient(screenX, screenY, endX, endY);
                gradient.addColorStop(0, `rgba(${brightness}, ${brightness}, ${brightness + 10}, 0)`);
                gradient.addColorStop(0.15, `rgba(${brightness}, ${brightness}, ${brightness + 10}, ${alpha})`);
                gradient.addColorStop(0.7, `rgba(${brightness}, ${brightness}, ${brightness + 10}, ${alpha * 0.7})`);
                gradient.addColorStop(1, `rgba(${brightness}, ${brightness}, ${brightness + 10}, 0)`);

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 1 + windIntensity;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(screenX, screenY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            });

            windAnimationId = requestAnimationFrame(drawWindAnimation);
        }

        // Start wind animation
        function startWindAnimation() {
            if (windAnimationId) {
                cancelAnimationFrame(windAnimationId);
            }
            initWindStreaks();
            windAnimationId = requestAnimationFrame(drawWindAnimation);
        }

        // Stop wind animation
        function stopWindAnimation() {
            if (windAnimationId) {
                cancelAnimationFrame(windAnimationId);
                windAnimationId = null;
            }
            // Clear wind canvas
            const canvas = document.getElementById('windCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Initialize all visualizations (static, no animation)
        function draw() {
            // Draw sky ribbon first so its dimensions are available for temperature curve positioning
            drawSkyRibbon();
            drawTemperatureCurve();
            startWindAnimation();
        }

        // Handle resize
        window.addEventListener('resize', () => {
            setTimeout(draw, 100);
        });

        // Fetch city suggestions from geocoding API
        async function fetchCitySuggestions(query) {
            if (query.length < 2) return [];
            const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5&language=en&format=json`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    return data.results.map(result => ({
                        name: result.name,
                        lat: result.latitude,
                        lon: result.longitude,
                        timezone: result.timezone,
                        country: result.country,
                        admin1: result.admin1 || ''
                    }));
                }
                return [];
            } catch (error) {
                console.error('Geocoding failed:', error);
                return [];
            }
        }

        // City label click handling
        let isEditingCity = false;
        let debounceTimer = null;
        let selectedSuggestion = null;

        function startCityEdit(e) {
            if (isEditingCity) return;
            isEditingCity = true;
            selectedSuggestion = null;

            // Get the current city label element (may have been recreated)
            const currentCityLabel = e ? e.currentTarget : document.getElementById('cityLabel');
            const currentName = currentCityLabel.textContent;

            // Create wrapper for input and suggestions
            const wrapper = document.createElement('div');
            wrapper.className = 'city-input-wrapper';

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'city-input';
            input.value = '';
            input.placeholder = currentName;

            wrapper.appendChild(input);
            currentCityLabel.replaceWith(wrapper);
            input.focus();

            // Create suggestions container
            const suggestionsContainer = document.createElement('div');
            suggestionsContainer.className = 'city-suggestions';
            suggestionsContainer.style.display = 'none';
            wrapper.appendChild(suggestionsContainer);

            function showSuggestions(suggestions) {
                suggestionsContainer.innerHTML = '';
                if (suggestions.length === 0) {
                    suggestionsContainer.style.display = 'none';
                    return;
                }

                suggestions.forEach(suggestion => {
                    const div = document.createElement('div');
                    div.className = 'city-suggestion';

                    const nameSpan = document.createElement('span');
                    nameSpan.className = 'city-suggestion-name';
                    nameSpan.textContent = suggestion.name;

                    const detailSpan = document.createElement('span');
                    detailSpan.className = 'city-suggestion-detail';
                    detailSpan.textContent = suggestion.admin1
                        ? `${suggestion.admin1}, ${suggestion.country}`
                        : suggestion.country;

                    div.appendChild(nameSpan);
                    div.appendChild(detailSpan);

                    div.addEventListener('mousedown', (e) => {
                        e.preventDefault(); // Prevent blur
                        selectCity(suggestion);
                    });

                    suggestionsContainer.appendChild(div);
                });

                suggestionsContainer.style.display = 'block';
            }

            async function selectCity(suggestion) {
                selectedSuggestion = suggestion;

                // Create a new city entry
                const cityKey = suggestion.name.toLowerCase().replace(/\s+/g, '-') + '-' + Date.now();
                cities[cityKey] = {
                    name: suggestion.name,
                    lat: suggestion.lat,
                    lon: suggestion.lon,
                    timezone: suggestion.timezone
                };
                currentCity = cityKey;
                currentDayOffset = 0; // Reset to today's view when changing location

                // Restore label first
                restoreLabel(suggestion.name, false);
                await refreshView();
                // Show "set as default" option after refresh completes
                showSetDefaultButton();
                // Prefetch remaining days for new city
                prefetchRemainingDays(cityKey);
            }

            function restoreLabel(name) {
                isEditingCity = false;
                if (debounceTimer) clearTimeout(debounceTimer);

                const newLabel = document.createElement('span');
                newLabel.className = 'city-label';
                newLabel.id = 'cityLabel';
                newLabel.textContent = name;
                wrapper.replaceWith(newLabel);
                newLabel.addEventListener('click', startCityEdit);
            }

            async function finishEdit() {
                if (selectedSuggestion) return; // Already handled by selectCity

                const newCityName = input.value.trim();

                if (newCityName) {
                    // Fetch suggestions and pick the first one
                    const suggestions = await fetchCitySuggestions(newCityName);
                    if (suggestions.length > 0) {
                        await selectCity(suggestions[0]);
                        return;
                    }
                }

                // No valid input or city not found, restore original
                restoreLabel(currentName);
            }

            // Debounced input handler for suggestions
            input.addEventListener('input', () => {
                if (debounceTimer) clearTimeout(debounceTimer);

                const query = input.value.trim();
                if (query.length < 2) {
                    suggestionsContainer.style.display = 'none';
                    return;
                }

                debounceTimer = setTimeout(async () => {
                    const suggestions = await fetchCitySuggestions(query);
                    showSuggestions(suggestions);
                }, 300);
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    suggestionsContainer.style.display = 'none';
                    finishEdit();
                } else if (e.key === 'Escape') {
                    if (debounceTimer) clearTimeout(debounceTimer);
                    restoreLabel(currentName);
                }
            });

            input.addEventListener('blur', () => {
                // Small delay to allow click on suggestion
                setTimeout(() => {
                    if (isEditingCity && !selectedSuggestion) {
                        finishEdit();
                    }
                }, 200);
            });
        }

        document.getElementById('cityLabel').addEventListener('click', startCityEdit);

        // Update city label when view refreshes
        function updateCityLabel() {
            const label = document.getElementById('cityLabel');
            if (label && cities[currentCity]) {
                label.textContent = cities[currentCity].name;
            }
        }

        // Show "set as default" button below city label
        function showSetDefaultButton() {
            // Remove any existing set-default button
            const existing = document.querySelector('.set-default-btn');
            if (existing) existing.remove();

            const cityLabel = document.getElementById('cityLabel');
            const setDefaultBtn = document.createElement('span');
            setDefaultBtn.className = 'set-default-btn';
            setDefaultBtn.textContent = 'set as default';
            setDefaultBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                saveDefaultCity(currentCity);
                setDefaultBtn.textContent = 'saved!';
                setTimeout(() => setDefaultBtn.remove(), 1500);
            });
            cityLabel.appendChild(setDefaultBtn);

            // Auto-hide after 8 seconds if not clicked
            setTimeout(() => {
                if (setDefaultBtn.parentNode) setDefaultBtn.remove();
            }, 8000);
        }

        // Handle day navigation
        document.getElementById('prevDay').addEventListener('click', async () => {
            currentDayOffset--;
            await refreshView();
            // Prefetch more past days if approaching the boundary
            if (currentDayOffset <= prefetchedPastBoundary + 3) {
                prefetchPastDays(currentCity, prefetchedPastBoundary);
            }
        });

        document.getElementById('nextDay').addEventListener('click', async () => {
            if (currentDayOffset < maxFutureOffset) {
                currentDayOffset++;
                await refreshView();
            }
        });

        // Click on day label to go to today
        document.getElementById('dayLabel').addEventListener('click', async () => {
            if (currentDayOffset !== 0) {
                currentDayOffset = 0;
                await refreshView();
            }
        });

        // Handle random capital button
        document.getElementById('randomBtn').addEventListener('click', async () => {
            // Pick a random capital different from current
            let randomCapital;
            do {
                randomCapital = worldCapitals[Math.floor(Math.random() * worldCapitals.length)];
            } while (cities[currentCity] && randomCapital.name === cities[currentCity].name);

            // Create a new city entry
            const cityKey = randomCapital.name.toLowerCase().replace(/\s+/g, '-') + '-' + Date.now();
            cities[cityKey] = {
                name: randomCapital.name,
                lat: randomCapital.lat,
                lon: randomCapital.lon,
                timezone: randomCapital.timezone
            };
            currentCity = cityKey;
            currentDayOffset = 0; // Reset to today's view

            // Skip temp range recalculation to keep the temperature bar unchanged
            await refreshView(true);
            showSetDefaultButton();
            prefetchRemainingDays(cityKey);
        });

        // Handle keyboard navigation for days
        document.addEventListener('keydown', async (e) => {
            if (e.key === 'ArrowLeft') {
                currentDayOffset--;
                await refreshView();
                // Prefetch more past days if approaching the boundary
                if (currentDayOffset <= prefetchedPastBoundary + 3) {
                    prefetchPastDays(currentCity, prefetchedPastBoundary);
                }
            } else if (e.key === 'ArrowRight' && currentDayOffset < maxFutureOffset) {
                currentDayOffset++;
                await refreshView();
            }
        });

        // Temperature tooltip on mousemove
        const tempOverlay = document.getElementById('tempCurveOverlay');
        const tempTooltip = document.getElementById('tempTooltip');

        // Position the overlay to cover from below sky tooltip area down to temperature curve
        function updateOverlayPosition() {
            const wrapper = document.getElementById('weatherDisplayWrapper');
            const skyRibbonEl = document.getElementById('skyRibbon');
            const daySelectorEl = document.querySelector('.day-selector');
            const wrapperRect = wrapper.getBoundingClientRect();
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const daySelectorRect = daySelectorEl.getBoundingClientRect();
            const height = wrapperRect.height || window.innerHeight * 0.6;

            // Calculate sky ribbon position relative to wrapper
            const skyBottomInWrapper = (skyRect.bottom - wrapperRect.top);

            // Get sky ribbon bounds relative to the wrapper
            const ribbonLeft = skyRect.left - wrapperRect.left;
            const ribbonWidth = skyRect.width;
            const skyTopInWrapper = skyRect.top - wrapperRect.top;

            // Sky tooltip stops at 144px from top of sky ribbon
            const visibleSkyHeight = 144;
            const tempOverlayTop = skyTopInWrapper + visibleSkyHeight;

            // Match the temperature curve positioning exactly as in drawTemperatureCurve()
            const curveHeight = Math.min(height * 0.396, 216);
            const curveBottom = skyBottomInWrapper + curveHeight * 0.8 - 160;

            // Stop overlay before the day selector (with 10px buffer)
            const daySelectorTopInWrapper = daySelectorRect.top - wrapperRect.top;
            const overlayBottom = Math.min(curveBottom + 20, daySelectorTopInWrapper - 10);

            // Ensure positive height, hide if invalid
            const overlayHeight = Math.max(0, overlayBottom - tempOverlayTop);

            tempOverlay.style.left = `${ribbonLeft}px`;
            tempOverlay.style.top = `${tempOverlayTop}px`;
            tempOverlay.style.width = `${ribbonWidth}px`;
            tempOverlay.style.height = `${overlayHeight}px`;
        }

        updateOverlayPosition();
        window.addEventListener('resize', updateOverlayPosition);

        tempOverlay.addEventListener('mousemove', (e) => {
            // Get sky ribbon bounds in screen coordinates (for mouse position comparison)
            const skyRibbonEl = document.getElementById('skyRibbon');
            const daySelectorEl = document.querySelector('.day-selector');
            const skyRect = skyRibbonEl.getBoundingClientRect();
            const daySelectorRect = daySelectorEl.getBoundingClientRect();
            const ribbonLeft = skyRect.left;  // Screen coordinates for mouse comparison
            const ribbonWidth = skyRect.width;

            const mouseX = e.clientX;
            const mouseY = e.clientY;

            // Hide tooltip if mouse is at or below the day selector
            if (mouseY >= daySelectorRect.top - 10) {
                tempTooltip.style.display = 'none';
                return;
            }

            // Calculate position along the ribbon (0 to 1)
            const t = (mouseX - ribbonLeft) / ribbonWidth;

            // Calculate hour from position (map t from display range to full 24h)
            const displayHours = displayEndHour - displayStartHour;
            const hour = Math.round(displayStartHour + t * displayHours);
            const hourStr = `${hour}h`;

            // Get temperature value using the same interpolation as the curve
            const tempNorm = interpolateDataSmooth(weatherData.temperature, t, true);

            // Convert normalized temperature back to Celsius
            // Normalization was: (temp + 25) / 60, so reverse: temp = norm * 60 - 25
            const tempCelsius = tempNorm * 60 - 25;

            // Get color for this temperature
            const tempColor = getTempColor(tempNorm);

            // Get wind data
            const windSpeedKmh = weatherData.windSpeedRaw ? interpolateData(weatherData.windSpeedRaw, t) : 0;

            // Build tooltip content
            let tempInfo = `<span style="color: rgb(${tempColor.r}, ${tempColor.g}, ${tempColor.b})">${tempCelsius.toFixed(1)}°C</span>`;
            if (windSpeedKmh > 15) {
                tempInfo += ` | ${Math.round(windSpeedKmh)} km/h wind`;
            }

            // Display the tooltip with hour on first line, temperature on second
            tempTooltip.innerHTML = `<div class="tooltip-hour">${hourStr}</div><div class="tooltip-value">${tempInfo}</div>`;
            tempTooltip.style.left = `${mouseX}px`;
            tempTooltip.style.top = `${mouseY}px`;
            tempTooltip.style.display = 'block';
        });

        tempOverlay.addEventListener('mouseleave', () => {
            tempTooltip.style.display = 'none';
        });

        // Touch device detection
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Sky tooltip on mousemove (desktop only - disabled on touch to allow tap navigation)
        const skyRibbon = document.getElementById('skyRibbon');
        const skyTooltip = document.getElementById('skyTooltip');

        if (!isTouchDevice) {
            skyRibbon.addEventListener('mousemove', (e) => {
                const rect = skyRibbon.getBoundingClientRect();
                const mouseX = e.clientX;
                const mouseY = e.clientY;

                // Calculate the sky portion height (excluding precipitation extension)
                // Sky portion ends at skyFadeEndY which is fullBaseHeight + skyExtensionHeight
                // But we display from cropAmount, so visible sky height is:
                // skyFadeEndY - cropAmount = (240 + 36) - (240 * 0.55) = 276 - 132 = 144px
                const visibleSkyHeight = 144; // Approximate visible sky height before precipitation area
                const skyBottomY = rect.top + visibleSkyHeight;

                // Hide tooltip when mouse is below the sky portion (in precipitation area)
                // This prevents interference with the temperature curve overlay
                if (mouseY > skyBottomY) {
                    skyTooltip.style.display = 'none';
                    return;
                }

                // Calculate position along the ribbon (0 to 1)
                const t = (mouseX - rect.left) / rect.width;

                // Calculate hour from position (map t from display range to full 24h)
                const displayHours = displayEndHour - displayStartHour;
                const hour = Math.round(displayStartHour + t * displayHours);
                const hourStr = `${hour}h`;

                // Get cloud cover value and daylight for color calculation
                const cloudValue = interpolateData(weatherData.clouds, t);
                const cloudPercent = Math.round(cloudValue * 100);
                const dayValue = interpolateData(weatherData.daylight, t);

                // Get precipitation data
                const precipMm = interpolateData(weatherData.precipMm, t);
                const precipProb = interpolateData(weatherData.precipProbability, t);
                const snowCm = weatherData.snowCm ? interpolateData(weatherData.snowCm, t) : 0;

                // Build tooltip text for weather info with color
                let cloudText, cloudColor;
                if (cloudPercent < 20) {
                    // Clear sky - show in blue
                    cloudText = 'clear sky';
                    cloudColor = 'rgb(100, 180, 235)';
                } else {
                    // Cloudy - use daytime gray color (always bright, regardless of time of day)
                    const rainValue = interpolateData(weatherData.rain, t);
                    const baseGray = Math.round(230 - cloudValue * 30 - rainValue * 40);
                    cloudText = `${cloudPercent}% clouds`;
                    cloudColor = `rgb(${baseGray}, ${baseGray}, ${baseGray})`;
                }

                let weatherInfo = `<span style="color: ${cloudColor}">${cloudText}</span>`;

                // Add precipitation info if there's any rain or snow
                if (snowCm > 0.1) {
                    // Show snow in white
                    weatherInfo += ` | <span style="color: rgb(255, 255, 255)">${snowCm.toFixed(1)}cm snow</span>`;
                } else if (precipMm > 0.1) {
                    // Show rain in blue
                    weatherInfo += ` | <span style="color: rgb(100, 180, 235)">${precipMm.toFixed(1)}mm rain</span>`;
                }

                // Add sunrise/sunset info if within 1 hour
                const currentHour = displayStartHour + t * (displayEndHour - displayStartHour);
                const sunriseHour = weatherData.sunriseHour;
                const sunsetHour = weatherData.sunsetHour;

                if (Math.abs(currentHour - sunriseHour) <= 1) {
                    // Get sky color at sunrise time
                    const sunriseDayValue = interpolateData(weatherData.daylight, (sunriseHour - displayStartHour) / (displayEndHour - displayStartHour));
                    const skyColor = getSkyColor(sunriseDayValue, 0);
                    const sunriseMinutes = Math.round((sunriseHour % 1) * 60);
                    const sunriseTimeStr = `${Math.floor(sunriseHour)}h${sunriseMinutes.toString().padStart(2, '0')}`;
                    weatherInfo += ` | <span style="color: rgb(${skyColor.bottom.r}, ${skyColor.bottom.g}, ${skyColor.bottom.b})">sunrise ${sunriseTimeStr}</span>`;
                } else if (Math.abs(currentHour - sunsetHour) <= 1) {
                    // Get sky color at sunset time
                    const sunsetDayValue = interpolateData(weatherData.daylight, (sunsetHour - displayStartHour) / (displayEndHour - displayStartHour));
                    const skyColor = getSkyColor(sunsetDayValue, 0);
                    const sunsetMinutes = Math.round((sunsetHour % 1) * 60);
                    const sunsetTimeStr = `${Math.floor(sunsetHour)}h${sunsetMinutes.toString().padStart(2, '0')}`;
                    weatherInfo += ` | <span style="color: rgb(${skyColor.bottom.r}, ${skyColor.bottom.g}, ${skyColor.bottom.b})">sunset ${sunsetTimeStr}</span>`;
                }

                // Display the tooltip with hour on first line, weather info on second
                skyTooltip.innerHTML = `<div class="tooltip-hour">${hourStr}</div><div class="tooltip-value">${weatherInfo}</div>`;
                skyTooltip.style.left = `${mouseX}px`;
                skyTooltip.style.top = `${mouseY}px`;
                skyTooltip.style.display = 'block';
            });

            skyRibbon.addEventListener('mouseleave', () => {
                skyTooltip.style.display = 'none';
            });
        }

        if (isTouchDevice) {
            document.body.classList.add('touch-device');

            // Show tap indicator briefly, then hide it
            const swipeIndicator = document.getElementById('swipeIndicator');
            setTimeout(() => {
                swipeIndicator.classList.add('hidden');
            }, 3000);

            // Tap left/right side of sky ribbon to navigate days
            const skyRibbonTouch = document.getElementById('skyRibbon');
            let touchStartX = 0, touchStartY = 0;

            skyRibbonTouch.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            skyRibbonTouch.addEventListener('touchend', async (e) => {
                const touchEndX = e.changedTouches[0].screenX;
                const touchEndY = e.changedTouches[0].screenY;
                const deltaX = Math.abs(touchEndX - touchStartX);
                const deltaY = Math.abs(touchEndY - touchStartY);

                // Only trigger on tap (minimal movement), not drag/scroll
                if (deltaX > 20 || deltaY > 20) return;

                const rect = skyRibbonTouch.getBoundingClientRect();
                const tapX = touchEndX - rect.left;
                const ribbonWidth = rect.width;

                // Tap on left third = previous day, right third = next day
                if (tapX < ribbonWidth * 0.33) {
                    currentDayOffset--;
                    await refreshView();
                    // Prefetch more past days if approaching the boundary
                    if (currentDayOffset <= prefetchedPastBoundary + 3) {
                        prefetchPastDays(currentCity, prefetchedPastBoundary);
                    }
                } else if (tapX > ribbonWidth * 0.67 && currentDayOffset < maxFutureOffset) {
                    currentDayOffset++;
                    await refreshView();
                }
            }, { passive: true });
        } else {
            // Hide tap indicator on non-touch devices
            const swipeIndicator = document.getElementById('swipeIndicator');
            swipeIndicator.style.display = 'none';
        }

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js').catch(err => {
                console.log('Service worker registration failed:', err);
            });
        }

        // Start - show loading immediately and initialize
        document.getElementById('loadingOverlay').classList.add('visible');
        updateCityLabel(); // Set initial city label from saved default
        refreshView().then(() => {
            // After initial view is loaded, prefetch remaining days in background
            prefetchRemainingDays(currentCity);
        });

        // Auto-refresh every hour to keep weather data current
        setInterval(() => {
            console.log('Auto-refreshing weather data...');
            currentDayOffset = 0; // Reset to current day
            refreshView();
        }, 60 * 60 * 1000); // 1 hour in milliseconds
    </script>
</body>
</html>
